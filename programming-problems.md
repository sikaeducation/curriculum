# Programming Problems

## Table of Contents

### Collections

* [Stable Employment Problem](#stable-employment-problem)
* [Store Inventory Manager](#store-inventory-manager)
* [Price Lookup Greedy Seller](#price-lookup-greedy-seller)
* [Wheel of Fortune](#wheel-of-fortune)
* [Nested Arrays to Nested Objects](#nested-arrays-to-nested-objects)
* [Frequency Count](#frequency-count)
* [Zip Arrays to Object](#zip-arrays-to-object)
* [Manipulating Arrays of Objects](#manipulating-arrays-of-objects)
* [Backronyms](#backronyms)

### Interpretation

* [Timing Functions](#timing-functions)
* [Roman Numerals](#roman-numerals)
* [Nested Functions](#nested-functions)
* [Higher-Order Functions](#higher-order-functions)
* [Ternaries](#ternaries)
* [Function Syntax](#function-syntax)

### Math

* [Guessing Game AI](#guessing-game-ai)
* [Async FizzBuzz](#async-fizzbuzz)
* [Streaming Statistics](#streaming-statistics)
* [Guessing Game](#guessing-game)
* [Fibonacci](#fibonacci)
* [Two Sum](#two-sum)
* [Sum Range](#sum-range)
* [Name That Number](#name-that-number)
* [Squares From Rectangles](#squares-from-rectangles)
* [Sum of Squares](#sum-of-squares)
* [Buying a Car](#buying-a-car)
* [Financing on Another Planet](#financing-on-another-planet)
* [Algebra Tortoise Race](#Algebra Tortoise Race)
* [Hex Class](#hex-class)
* [Find Odd and Even Divisors](#find-odd-and-even-divisors)
* [Find the Biggest Number You Can Make](#find-the-biggest-number-you-can-make)
* [Build a House of Cards](#build-a-house-of-cards)
* [Count Permutations Without Repetitions](#count-permutations-without-repetitions)
* [Checksum](#checksum)
* [Harshad/Niven Numbers](#harshad/niven-numbers)
* [Binary to Hex](#binary-to-hex)
* [Hex to Binary](#hex-to-binary)
* [Diagonal Sum](#diagonal-sum)
* [Parse and Compare Probabilities](#parse-and-compare-probabilities)
* [Functional Arithmetic](#functional-arithmetic)
* [Stacking Cubes](#stacking-cubes)
* [Equivalent Numbers](#equivalent-numbers)
* [Sum Between Two Integers](#sum-between-two-integers)
* [Iterative Powers of 4](#iterative-powers-of-4)
* [Recursive Powers of 4](#recursive-powers-of-4)
* [Binary to Decimal](#binary-to-decimal)
* [Sum of Multiples of 3 and 5](#sum-of-multiples-of-3-and-5)
* [Lychrel Numbers](#lychrel-numbers)
* [Product of Largest Pair of Integers](#product-of-largest-pair-of-integers)
* [Curried Addition](#curried-addition)
* [Multiply String](#multiply-string)
* [Divide String](#divide-string)
* [Add String](#add-string)
* [Subtract String](#subtract-string)
* [Stair Permutations](#stair-permutations)

### String Manipulation

* [Apple Building]_(#apple-building)
* [Weird Words](#weird-words)
* [Rotate For Maximum](#rotate-for-maximum)
* [Jaden Casing](#jaden-casing)
* [Credit Card Mask](#credit-card-mask)
* [Date to Day](#date-to-day)
* [Christmas Tree](#christmas-tree)
* [Combine Sort Dedupe String](#combine-sort-dedupe-string)
* [Compare Strings By Sum of Letter Values](#compare-strings-by-sum-of-letter-values)
* [Word Frequency Counter](#word-frequency-counter)
* [All Possible Anagrams](#all-possible-anagrams)
* [Checking DNA Sequences](#checking-dna-sequences)
* [Count String Islands](#count-string-islands)
* [Building Stair-Step Strings](#building-stair-step-strings)
* [Accumulate String](#accumulate-string)
* [Truncation](#truncation)
* [String Ending Matching](#string-ending-matching)
* [Reverse Vowels](#reverse-vowels)
* [Double Characters](#double-characters)
* [Remove Vowels](#remove-vowels)
* [Replace With Alphabet Position](#replace-with-alphabet-position)
* [String Frequency Count](#string-frequency-count)
* [Capitalize First Two Words](#capitalize-first-two-words)
* [Find the Path to a String Match in JSON](#find-the-path-to-a-string-match-in-json)
* [Are Strings Permutations?](#are-strings-permutations?)
* [String Permutation Checker](#string-permutation-checker)
* [Parse Query Strings](#parse-query-strings)
* [Unique Character Checker](#unique-character-checker)
* [Vowel Checker](#vowel-checker)
* [Parens Checker](#parens-checker)
* [Reverse a String Pure](#reverse-a-string-pure)
* [Reverse a String In Place](#reverse-a-string-in-place)
* [Enumerate String Reversal Strategies](#enumerate-string-reversal-strategies)
* [Strip Whitespace](#strip-whitespace)
* [Double Consonants](#double-consonants)
* [Identify Vowels](#identify-vowels)
* [Count Vowels](#count-vowels)
* [Remove Duplicate Characters](#remove-duplicate-characters)
* [Remove Duplicate Characters Case Insensitive](#remove-duplicate-characters-case-insensitive)
* [Palindrome Checker](#palindrome-checker)

### Arrays

* [Memory Game](#memory-game)
* [Find The Nth Longest Word](#find-the-nth-longest-word)
* [Sorting Callbacks](#sorting-callbacks)
* [Merge and Sort](#merge-and-sort)
* [Map and Reduce](#map-and-reduce)
* [Sets](#sets)
* [Top Three Values](#top-three-values)
* [Min Max List Values](#min-max-list-values)
* [Checkerboard](#checkerboard)
* [Two Dimensional Array Sorting Don't Drink The Water](#two-dimensional-array-sorting-don't-drink-the-water)
* [Compound Array](#compound-array)
* [Check Ascending](#check-ascending)
* [Find Similar Items](#find-similar-items)
* [Rotate Arrays](#rotate-arrays)
* [Flatten Array](#flatten-array)
* [Implement Every](#implement-every)
* [Implement .all](#implement-.all)
* [Implement .none](#implement-.none)
* [Implement .any](#implement-.any)
* [Implement Filter](#implement-filter)
* [Implement Intersect](#implement-intersect)
* [Implement Map](#implement-map)
* [Implement Reduce](#implement-reduce)
* [Average with forEach](#average-with-forEach)
* [Find All Greater Integers](#find-all-greater-integers)
* [Element Match Checker](#element-match-checker)
* [Join and Sort Array](#join-and-sort-array)
* [While Loop Number Manipulation](#while-loop-number-manipulation)
* [Missing Integer Checker](#missing-integer-checker)
* [Only Once Checker](#only-once-checker)
* [Grade Deltas](#grade-deltas)
* [More Than Once Checker](#more-than-once-checker)
* [Implement indexOf](#implement-indexof)
* [Twice Checker](#twice-checker)
* [Find the Longest String](#find-the-longest-string)
* [For and While Loop Practice](#for-and-while-loop-practice)
* [Implementing Max](#implementing-max)
* [Scores to Letter Grades](#scores-to-letter-grades)
* [Zip Arrays](#zip-arrays)
* [Rotate Even Indexes of a String](#rotate-even-indexes-of-a-string)
* [Count Present Sheep](#count-present-sheep)
* [Comparing Two Arrays: Conference City Picker](#comparing-two-arrays:-conference-city-picker)

## Collections

### Stable Employment Problem

Today we're going to solve an age-old problem that has plagued mountain villages and startups alike.
Given two entities that have preferences for matching, how do you ensure that these matchups are "stable"?

When we talk about stability, we mean that if two entities prefer each other over the partner they are matched with, the arrangement is not stable.

Given a list of developers, match them to companies. Match them such that no developer prefers a company that also prefers that developer over the one they are matched with. 
The "preferences" property represents an ordered list of preferences, with the first element being the most preferred.

```js
var developers = [
	{
		name: "Liz",
		preferences : [
			"AirBnB",
			"Facebook",
			"Pivotal",
			"Amazon",
			"Lyft",
			"Uber"
		]
	},
	{
		name: "Tyler",
		preferences : [
			"Lyft",
			"Facebook",
			"Pivotal",
			"AirBnB",
			"Amazon",
			"Uber"
		]
	},
	{
		name: "Cho",
		preferences : [
			"Uber",
			"Amazon",
			"Facebook",
			"AirBnB",
			"Pivotal",
			"Lyft"
		]
	},
	{
		name: "Zubair",
		preferences : [
			"AirBnB",
			"Pivotal",
			"Facebook",
			"Amazon",
			"Lyft",
			"Uber"
		]
	},
	{
		name: "Rosa",
		preferences : [
			"AirBnB",
			"Lyft",
			"Uber",
			"Facebook",
			"Pivotal",
			"Amazon"
		]
	}
];

var companies = [
	{
		name: "AirBnB",
		preferences : [
			"Liz",
			"Tyler",
			"Cho",
			"Zubair",
			"Rosa"
		]
	},
	{
		name: "Facebook",
		preferences : [
			"Cho",
			"Liz",
			"Tyler",
			"Zubair",
			"Rosa"
		]
	},
	{
		name: "Pivotal",
		preferences : [
			"Tyler",
			"Zubair",
			"Liz",
			"Cho",
			"Rosa"
		]
	},
	{
		name: "Amazon",
		preferences : [
			"Rosa",
			"Tyler",
			"Cho",
			"Zubair",
			"Liz"
		]
	},
	{
		name: "Lyft",
		preferences : [
			"Rosa",
			"Cho",
			"Zubair",
			"Liz",
			"Tyler"
		]
	},
	{
		name: "Uber",
		preferences : [
			"Liz",
			"Tyler",
			"Cho",
			"Zubair",
			"Rosa"
		]
	}
];
```

### Store Inventory Manager

Hi and welcome to team Gilded Rose.

You are asked to fix the code for our store management system.

All items have a `sell_in` value which denotes the number of days we have left to sell the item and a `quality` value which denotes how valuable the item is. 

At the end of each day our software should lower both values for every item.

Pretty simple, right? Well this is just the general rule with some exception:

* Once the `sell_in` days is less then zero, `quality` degrades twice as fast;
* The `quality` of an item can never be negative or increase beyond 50;
* The "Aged Brie" goods actually increases in quality each passing day;
* "Sulfuras" goods, being legendary items, never change their `sell_in` or `quality` values;
* "Backstage passes", like aged brie, increases in `quality` as its `sell_in` value decreases;
* Not just that: for "backstage passes" `quality` increases by 2 when there are 10 days or less and by 3 when there are 5 days or less but `quality` drops to 0 after the concert (`sell_in` 0 or lower).

Complicated enough, now? Well, there is a new item category that we would like to see added to the inventory management system:

* "Conjured" items degrade in quality twice as fast as normal items.
* You can change the `update_quality` method, add any new code, but you should NOT edit the item constructor/class: It belongs to the goblin in the corner who will insta-rage and one-shot you as he doesn't believe in shared code ownership.

Just for extra clarification, an item can never have its `quality` increase above 50, however "Sulfuras" is a legendary item and as such its `quality` is 80 and it never alters.

You won't find mixed categories (like a "Conjured Sulfuras / Backstage pass of Doom"), but the category name may be not in the first position (ie: expect something like "SuperUberSword, Conjured" or "Mighty Sulfuras Armour of Ultimate Awesomeness").

```js
function Item(name, sell_in, quality) {
  this.name = name;
  this.sell_in = sell_in;
  this.quality = quality;
}

var items = []

items.push(new Item('+5 Dexterity Vest', 10, 20));
items.push(new Item('Aged Brie', 2, 0));
items.push(new Item('Elixir of the Mongoose', 5, 7));
items.push(new Item('Sulfuras, Hand of Ragnaros', 0, 80));
items.push(new Item('Backstage passes to a TAFKAL80ETC concert', 15, 20));
items.push(new Item('Conjured Mana Cake', 3, 6));

function update_quality() {
  for (var i = 0; i < items.length; i++) {
    if (items[i].name != 'Aged Brie' && items[i].name != 'Backstage passes to a TAFKAL80ETC concert') {
      if (items[i].quality > 0) {
        if (items[i].name != 'Sulfuras, Hand of Ragnaros') {
          items[i].quality = items[i].quality - 1
        }
      }
    } else {
      if (items[i].quality < 50) {
        items[i].quality = items[i].quality + 1
        if (items[i].name == 'Backstage passes to a TAFKAL80ETC concert') {
          if (items[i].sell_in < 11) {
            if (items[i].quality < 50) {
              items[i].quality = items[i].quality + 1
            }
          }
          if (items[i].sell_in < 6) {
            if (items[i].quality < 50) {
              items[i].quality = items[i].quality + 1
            }
          }
        }
      }
    }
    if (items[i].name != 'Sulfuras, Hand of Ragnaros') {
      items[i].sell_in = items[i].sell_in - 1;
    }
    if (items[i].sell_in < 0) {
      if (items[i].name != 'Aged Brie') {
        if (items[i].name != 'Backstage passes to a TAFKAL80ETC concert') {
          if (items[i].quality > 0) {
            if (items[i].name != 'Sulfuras, Hand of Ragnaros') {
              items[i].quality = items[i].quality - 1
            }
          }
        } else {
          items[i].quality = items[i].quality - items[i].quality
        }
      } else {
        if (items[i].quality < 50) {
          items[i].quality = items[i].quality + 1
        }
      }
    }
  }
}
```

```js
//Testing one day lapse
update_quality();

describe('fix the code', function() {
   it("Testing "+items[0].name,function(){
   assert.equal(items[0].sell_in,9,"Expected different value");
   assert.equal(items[0].quality,19,"Expected different value");
   });
   it("Testing "+items[1].name,function(){
   assert.equal(items[1].sell_in,1,"Expected different value");
   assert.equal(items[1].quality,1,"Expected different value");
   });
   it("Testing "+items[2].name,function(){
   assert.equal(items[2].sell_in,4,"Expected different value");
   assert.equal(items[2].quality,6,"Expected different value");
   });
   it("Testing "+items[3].name,function(){
   assert.equal(items[3].sell_in,0,"Expected different value");
   assert.equal(items[3].quality,80,"Expected different value");
   });
   it("Testing "+items[4].name,function(){
   assert.equal(items[4].sell_in,14,"Expected different value");
   assert.equal(items[4].quality,21,"Expected different value");
   });
   it("Testing "+items[5].name,function(){
   assert.equal(items[5].sell_in,2,"Expected different value");
   assert.equal(items[5].quality,4,"Expected different value");  
   });
});
```

```js
function update_quality() {
  for (var i = 0; i < items.length; i++) {
    let item = items[i];
    
    const maxQuality = Math.max(50, item.quality);
    
    if(item.name.indexOf("Aged Brie") >= 0){
      item.quality = Math.min(maxQuality, item.quality + 1);
    } else if (item.name.indexOf("Backstage") >= 0) {
      item.quality = (item.sell_in > 1) * (Math.min(maxQuality, item.quality + (item.sell_in <= 6 ? 3 : item.sell_in <= 11 ? 2 : 1)));
    } else if (item.name.indexOf("Sulfuras") < 0) {      
      item.quality = item.quality - (/Conjured/i.test(item.name) ? 2 : 1) * (item.sell_in > 0 ? 1 : 2);
    }
    if(item.name.indexOf("Sulfuras") < 0){      
      item.quality = Math.max(0, item.quality)
      item.sell_in = item.sell_in - 1
    }    
  }
}
```

### Price Lookup Greedy Seller

In this warmup you will write a method which returns a quote for a give quantity of items. Stock items are represented as a list of objects. Each item has the following properties:

* `quantity` (integer)
* `unit price` (decimal)
* `unit margin` (decimal)

As you can see your stock is composed from single type of items. Each batch is bought from a different supplier, so it comes with it's own unit price and unit margin (i.e. your profit). Available items will be passed to constructor of Quoter class as a list.

Your task is to write getQuote method. It should return the best price for a given quantity of items. However, your boss is rather greedy, so best quote is one that maximises your margin. Note that call to getQuote method should not modify stock passed into Quoter constructor, i.e. multiple call to getQuote should operate on the same stock. Your method should return the following string:

* "Your order cannot be fulfilled, try lower quantity" if you don't have enough stock
* "Your best quote for x items is y" is you have enought items in stock

Some examples to get you started:

```js
var quoter = new Quoter([]);     
quoter.getQuote(1); // should return "Your order cannot be fulfilled, try lower quantity"

var items = [{ quantity: 10, unitPrice: 100, unitMargin: 1 }, { quantity: 10, unitPrice: 110, unitMargin: 1.1 }];   
var quoter = new Quoter(items);     
quoter.getQuote(10); //should return "Your best quote for 10 items is 1100.00"
```

```js
describe('Quoter', function() {
  quoter = new Quoter([]);
  it('should return a string when it will not fulfull the order', function() {
    expect(quoter.getQuote(1)).to.equal("Your order cannot be fulfilled, try lower quantity");
  });

  quoter2 = new Quoter([{quantity: 10, unitPrice: 100, unitMargin: 1}]);
  it('should return the best order', function() {
    expect(quoter2.getQuote(11)).to.equal("Your order cannot be fulfilled, try lower quantity");
  });

  quoter3 = new Quoter([{quantity: 10, unitPrice: 100, unitMargin: 1}]);
  it('should return the best order', function() {
    expect(quoter3.getQuote(10)).to.equal("Your best quote for 10 items is 1000.00");
  });

  quoter4 = new Quoter([{quantity: 10, unitPrice: 100, unitMargin: 1.1}, {quantity: 10, unitPrice: 110, unitMargin: 1}]);
  it('should return the best order', function() {
    expect(quoter4.getQuote(15)).to.equal("Your best quote for 15 items is 1550.00");
  });
});
```

```js
function Quoter(items) {
  this.items = (items || []).sort(function (item_a, item_b) { return item_a.unitMargin < item_b.unitMargin;});
  this.quantity = this._getQuantity();
}

Quoter.prototype._getQuantity = function () {
  return this.items.reduce(function (previous, current) { return previous + current.quantity; }, 0);
}

Quoter.prototype._getQuote = function (quantity) {
  return this.items.reduce(function (previous, current) {
    var units = quantity > current.quantity ? current.quantity : quantity;
    var actual = units * current.unitPrice;
    quantity = quantity - units;
    return previous + actual;
  }, 0);
}

Quoter.prototype.getQuote = function(quantity) {
  if (this.quantity >= quantity) {
    var price = this._getQuote(quantity);
    return 'Your best quote for '+ quantity +' items is ' + Number(price).toFixed(2);
  
  } else {
    return 'Your order cannot be fulfilled, try lower quantity';
  }
}
```

### Wheel of Fortune

Three candidates take part in a TV show.

In order to decide who will take part in the final game and probably become rich, they have to roll the Wheel of Fortune!

The Wheel of Fortune is divided into 20 sections, each with a number from 5 to 100 (only mulitples of 5).

Each candidate can roll the wheel once or twice and sum up the score of each roll. The winner one that is closest to 100 (while still being lower or equal to 100). In case of a tie, the candidate that rolled the wheel first wins.

You receive the information about each candidate as an array of objects: each object should have a name and a scores array with the candidate roll values.

Your solution should return the name of the winner or false if there is no winner (all scored more than 100).

Example:

```js
var c1 = { name: "Bob", scores: [10, 65] };
var c2 = { name: "Bill", scores: [90, 5] };
var c3 = { name: "Charlie", scores: [40, 55] };
winner([c1, c2, c3]); // Returns "Bill"
```

Please note that inputs may be invalid: in this case, the function should return false.

Potential errors derived from the specifications are:

* More or less than three candidates take part in the game.
* A candidate did not roll the wheel or rolled it more than twice.
* Scores are not valid.
* Invalid user entry (no name or no score).

```js
describe('wheel of fortune', function() {
  it('should return Bill', function() {
        var c1 = { name: "Bob", scores: [10, 65] };
        var c2 = { name: "Bill", scores: [90, 5] };
        var c3 = { name: "Charlie", scores: [40, 55] };
    expect(winner([c1, c2, c3])).to.equal('Bill');
  });
});
```

```js
function winner(candidates) {
  if (candidates.length !== 3) {
    return false
  }
  
  var winner = false
  var winnerScore = 0
  
  for (var i = 0; i < 3; i++) {
    var candidate = candidates[i]
    var scores = candidate.scores
    
    if (!candidate.name || !Array.isArray(scores)) {
      return false
    }
    
    if (scores.length === 0 || scores.length > 2) {
      return false
    }
    
    var a = scores[0]
    var b = scores[1] || 0
    
    if (a % 5 || b % 5 || a > 100 || b > 100) {
      return false
    }
    
    var score = a + b
    if (score <= 100 && score > winnerScore) {
      winnerScore = score
      winner = candidate.name
      
      if (score === 100) break
    }
  }
  
  return winner
}
```

### Nested Arrays to Nested Objects

Write a function that takes nested arrays and turns it into nested objects. If you solve it one way, then solve it another.

```
var books = [
  ["Learn to Program", "Chris Pine", 1934356360],
  ["Eloquent Javascript", "Marijn Haverbeke", 1593275846]
]

bookData(books)
//-> {
  "1934356360": {
    "title": "Learn to Program",
    "author": "Chris Pine",
    "isbn10": 1934356360
  },
  "1593275846": {
    "title": "Eloquent Javascript",
    "author": "Marijn Haverbeke",
    "isbn10": 1593275846
  }
}
```

### Frequency Count

Write a function that takes an array and returns an object where each key is an item from the array and the corresponding value is how many times that item was in the array.

Example:

var list = ['a', 'b', 'c', 'a', 'b'];

sumInstances(list);
// => { a: 2, b: 2, c: 1 }

### Zip Arrays to Object

Write a function that uses one or more loops and takes two arrays and returns an object that has the items in the first array as properties and the items in the second array as values.

```
var array1 = [ "cat", "dog", "fish" ],
    array2 = [ "lion", "pointer", "trout" ]

animalMatch(array1, array2);
//-> animals = {
  cat: "lion",
  dog: "pointer",
  fish: "trout"
}
```

### Manipulating Arrays of Objects

Implement each of these functions.

```
var people = [{name:'A', age: 20}, {name:'B', age: 30}, {}, {name:'', age: 10}];

removeBadPeople(people);
// => [{name:'A', age: 20}, {name:'B', age: 30}];

sumAgesValid(people);
// => 50

sumAgesAll(people);
// => 60
```

### Backronyms

Write a function that takes an acronym as an argument and returns a sentence that it could represent.

Example:
```
backronym('ABCD');
// => April Building Caller District
```

## Interpretation

### Timing Functions

Designing a good timing experiment can help you on the job when you're working on performace optimizations, and also for writting benchmarking tests. This warmup is a challange to design such an experiment in order to better understand how timing code works. 

First, examine this function which, when called will print the time at which the function started, and the the when the setTimeout event returned from the event loop -- roughly 500ms but as you'll see it's not exact.

Read the function. Once you understand how it works move on to the next comment. 

* Hint: Try running this program in your console and see what prints.
* Hint: Lookup what new Date.getTime() does.

```js
function timeTimeout(callbackFunction) {
	var startTime = new Date().getTime();

	setTimeout(function(){
		// ALWAYS get the timestamp before you do any
		// logging or other work -- otherwise your time 
		// will be impacted by writing to the console, 
		// which is very slow.
		var endTime = new Date().getTime();
		var millisecondsElapsed = endTime - startTime;

		if(callbackFunction === undefined) {
			console.log("START TIME: " + startTime);
			console.log("END TIME  : " + endTime);
			console.log("ELASPED   :"  + millisecondsElapsed);
			console.log("callbackFunction was undefined -- exit\n\n");
		}
		else {
			callbackFunction(millisecondsElapsed);	
		}
	}, 500)
}

timeTimeout();
```

Hint: You will have to use the fact that timeTimeout accepts a callback function which passes the elapsed milliseconds as its parameter.

```js
timeTimeout(function(millisecondsElapsed){
	console.log("Entered Callback Function===");
	console.log("Time elapsed: " + millisecondsElapsed);
	console.log("\n\n");
});
```

It's interesting that the two calls setTimeout frequently don't take the same amount of time, if you didn't notice this run the program a few times in a row. Your task is to complete this function so that it computes the average amount of time in milliseconds it really takes for setTimeout() to trigger it's callback.  

How much more than the specified 500ms does it seem to be off by? 

```js
function computeAverageTime() {

}
```


 ==================== Part Two =====================

Below are two programs to solve the same popular problem:
 
compute the nth digit of the fibbonacci sequence: [1, 1, 2, 3, 5, 8, 13, 21, 34 ...]

One is recursive, and one is iterative; One is also slower. Write some code that can prove that the recursive solution is slower, by timing both functions. 

Once you've got the functions timed, experiment with changing the value of n and see how it affects the time for each version differently.

```js
function timeFibbonacciVersions(){

}
```

Do not alter these two functions.

```js
function fibbonacciRecursive(n) {
	if(n <= 1) {
		return 1;
	}

	return fibbonacciRecursive(n - 1) + fibbonacciRecursive(n - 2);
}

function fibbonacciIterative(n) {
	if(n <= 1) {
		return 1;
	}

	var fibNumber;
	var numberOne = 1;
	var numberTwo = 1;

	for(var i = 1; i < n; i++) {
		fibNumber = numberOne + numberTwo;
		numberOne = numberTwo;
		numberTwo = fibNumber;
	}

	return fibNumber;
}
```

```js
function computeAverageTimeOverlapping() {
	var times = [];
	var sumOfTimes = 0;

	for(var i = 0; i < 100; i++) {
		timeTimeout(function(ms) {
			times.push(ms);
			sumOfTimes += ms;

			if(times.length === 100) {
				console.log("Timings complete, avg time:")
				console.log(sumOfTimes / times.length);
			}
		});
	}
}

function computeAverageTimeNoOverlap() {
	var times = [];
	var sumOfTimes = 0;

	function handler(ms){
		times.push(ms);
		sumOfTimes += ms;

		if(times.length === 100) {
			console.log("Timings complete, avg time:")
			console.log(sumOfTimes / times.length);
		}
		else {
			timeTimeout(handler);
		}
	}

	timeTimeout(handler);
}
```

```js
function timeFibbonacciVersions(){
	// See the Fibonacci directory benchmarking.js in this 
	// same repository for more detailed and robust solution:

	var recursiveStart = new Date().getTime();
	fibbonacciRecursive(30);
	var recursiveEnd = new Date().getTime();

	var iterativeStart = new Date().getTime();
	fibbonacciIterative(30);
	var iterativeEnd = new Date().getTime();

	var recursiveTime = recursiveEnd - recursiveStart;
	var iterativeTime = iterativeEnd - iterativeStart;

	if(recursiveTime > iterativeTime) {
		console.log("Recursive is slower");
	} else {
		console.log("Iterative is slower");
	}
}
```

### Roman Numerals

Students should be shown the unidentifiedCode.js file, and asked to descern what this code does. Once they correctly identify that it converts a string to it's roman numeral value, ask them to refactor the code so that it's easier to identify.

Once they've refactored, feel free to show them romanNumerals.js which should be eminently readable.

Writing code that other programmers can quickly read and understand is one of the most important skills a programmer can develop. Reading obfustacted code is a good way to develop intuition for what makes code hard to read later. 

Ask the students to think about what makes good variable and function name.  

```js
// What does this code do?
console.log(decodeString('abcdefg'));
console.log(decodeString('iv'));
console.log(decodeString('LiC'));

function decodeString(input) {

	var returnValue = 0;
	input = input.toLowerCase();
	
	for(var i = 0; i < input.length; i++) {
		var v1 = decodeChar(input[i]);
		var v2 = decodeChar(input[i+1]);

		if(v1 < v2) {
			returnValue -= v1;
		}
		else {
			returnValue += v1;
		}
	}
	
	return returnValue;

};

function decodeChar(c) {

	if(c === 'i') {
		return 1;
	}

	if(c === 'v') {
		return 5;
	}

	if(c === 'x') {
		return 10;
	}

	if(c === 'l') {
		return 50;
	}

	if(c === 'c') {
		return 100;
	}
};
```

```js
/**
 * This function will convert a string to it's roman numeral value.
 * If the string is not a valid roman numeral string, this function
 * will return NaN.
 */
function convertRomanNumeral(input) {
	// This constant could be globalized.
	var ROMAN_LOOKUP = {
		i: 1,
		v: 5,
		x: 10,
		l: 50,
		c: 100,
	};

	var sum = 0;
	var lowerCaseInput = input.toLowerCase();
	
	for(var i = 0; i < lowerCaseInput.length; i++) {
		var currentChar = lowerCaseInput[i],
		    nextChar    = lowerCaseInput[i+1];
		    
		var currentRomanValue = ROMAN_LOOKUP[currentChar],
		    nextRomanValue    = ROMAN_LOOKUP[nextChar]

		if(currentRomanValue < nextRomanValue) {
			sum -= currentRomanValue;
		}
		else {
			sum += currentRomanValue;
		}
	}
	
	return sum;
};
```

### Nested Functions

Mentally the following code example:

```javascript
function theBest() {
  function theWorst () {
    count -= 4;
  }

  var count = 10;

  function reallyTheBest () {
    count += 25;
  }

  reallyTheBest();
  reallyTheBest();
  reallyTheBest();
  theWorst();
  theWorst();
  reallyTheBest();

  return count;
}

console.log(theBest());
```

### Higher-Order Functions

Mentally the following code example:

```javascript
function addN(n) {
  return function(x) {
    return n + x;
  }
};

var addSix = addN(6);
var addTwo = addN(2);

console.log(addSix(10));
console.log(addSix(100));
console.log(addSix(100) + addTwo(10));
```

### Ternaries

What is wrong in the following code example:

```javascript
function shouldHire(candidate) {
  bestCandidate = candidate.qualified == 'yes' ? true : false;

  return bestCandidate ? 'Found em!' : 'Continue searching!';
}
```

### Function Syntax

What happens when the following code is entered into a node console or other JS interpreter?

```javascript
function greatCodeIsGreat(conditionsForGreatness {
  return 'All Code is Great Code... just kidding!';
}
```

## Math

### Guessing Game AI

* There are two players (one player, one AI).
* Each player writes a number, hidden from the other player. It can be any integer 1 through infinity. Players can only use each number once!
* The players reveal their numbers.
* Whoever chose the lower number gets 1 point, unless the lower number is lower by only 1, then the player with the higher number gets 2 points
* If they both chose the same number, neither player gets a point.
This repeats, and the game ends when one player has 5 points.

The challenge is to write a script to play this game. Knowing the rules and all your opponent's previous numbers, can you program a strategy? You should really try playing this first with your friends â€” you'll see there's a deep human element to predicting your opponent's choice. Is it possible to program a strong strategy?

```js
var algo1 = require(process.argv[2])();
var algo2 = require(process.argv[3])();

var iterations = 100000;
var wins1 = 0;
var wins2 = 0;
var ties = 0;
var score1 = 0;
var score2 = 0;
var roundCounter = 0;
var algo1Used = [];
var algo2Used = [];

function computeScore(answer1, answer2) {
  if (answer1 + 1 === answer2) {
    score1 += 2;
  } else if (answer2 + 1 === answer1) {
    score2 += 2;
  } else if (answer1 < answer2) {
    score1++;
  } else if (answer1 > answer2) {
    score2++;
  }
}

function resetBoard() {
  score1 = 0;
  score2 = 0;
  roundCounter = 0;
  algo1Used = [];
  algo2Used = [];
}

function calculateWinner() {
  if (score1 > score2) {
    wins1++;
    console.log('Algorithm 1 wins!');
  } else if (score2 > score1) {
    wins2++;
    console.log('Algorithm 2 wins!');
  } else {
    ties++;
    console.log('Tie!');
  }
}

for (var i = 0; i < iterations; i++) {
  while (score1 < 5 && score2 < 5 && roundCounter < 10) {
    var answer1 = algo1(algo1Used, algo2Used, score1, score2);
    var answer2 = algo2(algo2Used, algo1Used, score2, score1);
    algo1Used.push(answer1);
    algo2Used.push(answer2);
    computeScore(answer1, answer2);
    roundCounter++;
  }
  calculateWinner();
  resetBoard();
}

console.log('Wins for algorithm 1: ' + wins1);
console.log('Wins for algorithm 2: ' + wins2);
console.log('Ties: ' + ties);
```

### Async FizzBuzz

This code currently waits 300 seconds, then calls the function fizz which prints "fizz". Extend this code to achieve the tasks listed below.

* After 500ms print buzz
* Count every 100ms and print the number of ms (100, 200, 300)
* Every 300 ms, print fizz
* Every 500 ms print buzz
* After 1500ms print fizzbuzz and stop all other printing functions.
* make it so 300 & fizz don't print, rather only fizz prints on the 300th ms
* Same for 500 and buzz

```js
setTimeout(fizz, 300);

function fizz() {
	console.log('fizz');
}
```

```js
var timesSoFar = 0;

var start = new Date().getTime();
console.log(start);

var intervalId = setInterval(printANumber, 100);

setTimeout(function(){
	console.log("FIRST!")
	clearInterval(intervalId);
}, 1500);

function printANumber(){
	var ms = new Date().getTime();
	timesSoFar += 100;
	
	if(timesSoFar % 300 === 0 && timesSoFar % 500 === 0){
		console.log('fizzbuzz');
		console.log(intervalId);
		clearInterval(intervalId);
	}
	else if(timesSoFar % 300 === 0) {
		console.log('fizz');
	}
	else if(timesSoFar % 500 === 0) {
		console.log('buzz');
	}
	else {
		console.log(timesSoFar);
	}
}
```

### Streaming Statistics

This one is tricky, particularly the median function. First introduce the notion of getting the mean and median of an array. These concepts are fairly straight forward, and you can show the code in the test function as an example of doing this. 

Then, mention that storing all that data in an array doesn't scale well. We run out of memory and we can't sort quickly enough as our data set grows. How can we solve this problem?

The Stream object is meant to store the minimum amount of data possible to compute (or track) the mean, median, and sum of the items that have been pushed to it.

Then talk about benchmarking when students finish!

In programming, often there are performance constraints that prevent us from using the most intuitive approach to a problem.
 
In this warmup, we need to be able to compute the sum, average, and median of a very long array of numbers. Unfortunately, using an Array to hold all the values, and computing the sum, average, median, and count is too slow and uses too much memory. 

Instead, we need a data structure that stores significantly less data but contains enough information to get the values we care about. 

This Stream is meant to be such a data structure. Fill out this constructor function (including the bodies of the functions) such that:

* `this.count` returns the number of times `this.streamPush` has been called
* `this.sum` returns the sum of the values sent through `this.streamPush`
* `this.average` returns the average of the values sent through `this.streamPush`
* `this.median` returns the median of the values sent through `this.streamPush`
* You may not use an array to store the values in stream push. 
* You may not change the names of the functions in `Stream()`

```js
function Stream() {

	this.count = function() {

	}

	this.sum = function() {

	}

	this.average = function() {

	}

	this.median = function() {
		
	}

	this.streamPush = function(num) {

	}
}
```

```js
/************************
 The test code starts here
*************************/

/*
This first test function creates 100 random numbers betweet 0 and 100. Then it adds them both to an array, and to a stream. After that, it prints out the sum, average, and median for each approach. You should see that they are always the same. 
*/

var passedRandomTest = false;
(function() {
	// Create a streamer, and an array. 
	var streamer = new Stream();
	var arr = [];

	// Add 100 random integers between 0-100 to each
	for(var i = 0; i < 100; i++) {
		var current = Math.floor(Math.random() * 100);
		streamer.streamPush(current);
		arr.push(current);
	}

	// This is how we get those values for an array
	arr.sort(function(a, b) {
	  return a - b;
	});

	// get the sum
	var sum = 0;
	for(var i = 0; i < arr.length; i++) {
		sum += arr[i];
	}

	// use the sum to get the average
	var avg = sum / arr.length;

	// get the median
	var median;
	if(arr.length % 2 === 0) {
		var itemOne = arr[(arr.length / 2)];
		var itemTwo = arr[(arr.length / 2) - 1];
		median = (itemOne + itemTwo) / 2;
	}
	else {
		median = arr[Math.floor(arr.length / 2)]
	}

	console.log("--sum--");
	console.log(sum);
	console.log(streamer.sum());

	console.log("\n--avg--");
	console.log(avg);
	console.log(streamer.average());

	console.log("\n--median--");
	console.log(median);
	console.log(streamer.median());

	passedRandomTest = (median === streamer.median() &&
		sum === streamer.sum() &&
		avg === streamer.average()) 
})();

// If your tests pass, automatically start the benchmarking!
if(!passedRandomTest) return;

console.log("TESTS PASSED, RUNNING BENCHMARKS!")
```

TIMING CODE -- Our Stream object is WAY MORE EFFECTIVE than an array. Not only do arrays run out of memory but it also slows down significantly as we add values.

This function benchmarks the array version. You'll see that it slows down with each new batch of random elements. You'll also notice that I explicitly end the do/while loop after arr.length becomes 70,000,000. My system crashed after that size, your results may vary. 

```js
(function() {
	var arr = [];
	console.log("\n\n=====Benchmarking the Array version ======");
	do {
		var start = new Date().getTime();

		for(var i = 0; i < 10000000; i++) {
			var current = Math.floor(Math.random() * 100);
			arr.push(current);
		}

		arr.sort(function(a, b) {
		  return a - b;
		});

		var sum = 0;
		for(var i = 0; i < arr.length; i++) {
			sum += arr[i];
		}

		var avg = sum / arr.length;

		var median;
		if(arr.length % 2 === 0) {
			var itemOne = arr[(arr.length / 2)];
			var itemTwo = arr[(arr.length / 2) - 1];
			median = (itemOne + itemTwo) / 2;
		}
		else {
			median = arr[Math.floor(arr.length / 2)]
		}
		var end = new Date().getTime();
		console.log("Successfully computed Array for size: " + arr.length);
		console.log("computing metrics for this size took " + (end - start) + "ms\n");
	} while(i < 70000000) // My system ran out of memory on 80000000
})();
```

Our Stream object will scale nearly infinitely, and the operations will run quickly no matter how many items we put in them. Unlike for Arrays, I didn't add any stopping code to this function. See if you can let it run long enough to run out of memory... Also notice how much FASTER this version of the code is!

Even when the Stream has handled double the limit of the array implementation, it's still ~10x faster. 

I hope this demonstration illustrates why programmers need to be able to find creative solutions to problems. Often the most "intuitive" way to solve a problem is not good enough.

```js
(function() {
	console.log("\n\n======Benchmarking the Stream version ======");
	var streamer = new Stream();
	while(true) {
		var start = new Date().getTime();
		for(var i = 0; i < 10000000; i++) {
			var current = Math.floor(Math.random() * 100);
			streamer.streamPush(current);
		}

		streamer.sum();
		streamer.average();
		streamer.median();

		var end = new Date().getTime();
		console.log("Successfully computed Stream for size: " + streamer.getCount());
		console.log("computing metrics for this size took " + (end - start) + "ms\n");
	}
})();
```
```js
function Stream() {
	// In order compute the sum, we only need to store one number. 
	var sum = 0;

	// In order to compute the average, we just need the sum and a
	// counter.
	var count = 0;

	// In order to store the median we need to know how many of 
	// each number we saw. 
	var numberCounts = {};

	this.getCount = function() {
		return count;
	}

	// Sum is easy, we keep the sum as we recieve numbers
	this.sum = function() {
		return sum;
	}

	// Median is tricky
	this.median = function() {
		// determine where the middle is
		var mid = count / 2;

		// determine if we need to return a 'mean of two' for the median
		var getTwo = (count / 2) % 2 === 0

		// we're going to count up until we get to 'mid'
		var numbersCounter = 0;

		// these variables are to enable us to perform the logic needed
		// to get a 'mean of two'
		var meanOfTwo;
		var seenFirst = false;

		// It's dangerous to assume the order of number counts
		// http://stackoverflow.com/questions/280713/elements-order-in-a-for-in-loop
		// The order of keys is "implementation specific"
		// meaning IE and Chrome are allowed to handle them differently

		// Because of this, I'm breaking the rules a little here
		// and using an array. However, the maximum size of this
		// array 'orderedKeys' is 100. why is that?
		var orderedKeys = Object.keys(numberCounts).sort(function(a, b) {
			return Number(a) - Number(b);
		});

		// That said, this commented out version of the for-loop works in node
		// firefox, and chrome. It's not "guaranteed" to work, but it does. Odd right?
		// this is called "implenetation specific behavior" and this
		// type of ambiguity exists in many languages. 
		// for(key in numberCounts) {

		for(var i = 0; i < orderedKeys.length; i ++) {
			key = orderedKeys[i]; // Comment out this line if you're using the other for loop
			numbersCounter += numberCounts[key];
			
			// If we have an even number of items and we're at 
			// EXACTLY the midpoint, then we have to look at the
			// next key to determine the median. This code handles that case.

			// IF we set seenFirst to true, we're on the second of
			// two for the mean of two. 
			// If (numbersCounter === mid && getTwo) then we're on the first of two 
			if(seenFirst || (numbersCounter === mid && getTwo)) {
				// If we haven't gotten the first of the two 
				// median values, save this key.
				if(!seenFirst) {
					meanOfTwo = Number(key);
					seenFirst = true;
				}
				// If we HAVE seen the first one, we can return
				// the sum of this key, and the last key, divided by 2
				else {
					return (meanOfTwo + Number(key)) / 2;
				}
			}
			// If we've gone PAST the midpoint on this particular
			// key, then regardless of whether the length is even or odd
			// we can just return the current key
			else if(numbersCounter >= mid) {
				return Number(key);
			}
		}
	}

	// Average is just the sum / count
	this.average = function() {
		return sum / count;
	}

	// When we stream a new value to our object
	// we need to update the sum, count, and numberCounts object.
	this.streamPush = function(num) {
		sum += num;
		count += 1;

		if(numberCounts[num] === undefined) {
			numberCounts[num] = 1;
		}
		else {
			numberCounts[num] += 1;
		}
	}
}
```

### Guessing Game

Your goal is to create a command line game, where users guess a randomly generated number between 1-100 until they have guessed correctly. 

```js
// You'll need to npm install prompt
var prompt = require('prompt');

// example of using prompt
prompt.get(['guess'], function (err, result) {
	console.log(result);
	console.log(result.guess);
});

var globalGuess = undefined;
var randomNumber = 3; // fix this to be random
```

Create a game, where users can guess until they guess correctly.

```js
var prompt = require('prompt');

var randomNumber = Math.floor((Math.random() * 100) + 1);
var counter = 0;	

prompt.message = "Pick a number between 1 and 100";

function numberGame(){
prompt.get(['guess'], function (err, result) {

	if (result.guess == randomNumber){
		console.log("Congratulations! You guess correctly!");
		console.log("Your number:" +result.guess);
		console.log("Computer's Number"+ randomNumber);
	}
	else if (result.guess < randomNumber) {
		console.log("You guessed too low! Try again!");
		counter ++;
		numberGame();
	}	
	else if (result.guess > randomNumber) {
		console.log("You guessed too high! Try again!");
		counter ++;
		numberGame();
	}

	if(counter > 3){
		console.log("Too many failed attempts! The number was "+ randomNumber + ". Your computer will now self destruct.");
	}
});
}

numberGame();
```

### Fibonacci

Give your students the prompt and see what the solutions they come up with look like. After that you can release the solutions and benchmarking files. The files themselves are runnable with test code, and with benchmarks.

The solutions and benchmarking are intended to show the weakness of recursion particularly, but also the strength of 'memoization' or 'caching' which is among the most common performance optimization techniques.

The Fibbonacci sequence is a never ending numerical sequence generated by adding the previous two numbers together to get the next number in the sequence. For convience the sequence starts with two 1's. So the first few numbers are as follows:

```
1,1,2,3,5,8,13,21,34 ... 
```

Complete the function fibbonacci below such that it accepts an integer input parameter n and returns the nth number in the sequence. So:

```
fibbonacci(0); // should return 1
fibbonacci(1); // should return 1
fibbonacci(2); // should return 2
fibbonacci(3); // should return 3
fibbonacci(4); // should return 5
```

```js
// Test function, checks the first few known values.
function testFib() {
	var fibTests = [1,1,2,3,5,8,13,21,34];
	var allPassing = true;
	
	for(var i = 0; i < fibTests.length; i++) {
		if(fibbonacci(i) !== fibTests[i]) {
			allPassing = false;
			console.log("failure for " + i + ".\n  Expected: " + fibTests[i] + "\n  Got: " + fibbonacci(i) + "\n");
		}
	}

	if(allPassing) {
		console.log("All tests passed");
	}
}
```

```js
describe('for Fibbonacci sequence', function() {
  it('when we pass in a value of 1 or less, expect to return 1', function() {
    expect(fibChecker.fibbonacciIterative(1)).to.equal(1)
    expect(fibChecker.fibbonacciIterative(0)).to.equal(1)
    expect(fibChecker.fibbonacciIterative(-1)).to.equal(1)
    expect(fibChecker.fibbonacciIterative(-1.5)).to.equal(1)
    expect(fibChecker.fibbonacciIterative(-10979686574)).to.equal(1)
  })
  it('when 4 is passed to fibChecker, expect to return 5', function() {
    expect(fibChecker.fibbonacciIterative(4)).to.equal(5)
  })
})
```

```js
/* 
 There are two common approaches to this problem. The first is recursive the second
 is iterative.
*/

// Recursive, meaning we call this function from inside itself.
function fibbonacciRecursive(n) {
	// Base case, if n is 0 or 1 just return 1.
	if(n <= 1) {
		return 1;
	}

	// Recursive step, return the sum of the previous two iterations
	return fibbonacciRecursive(n - 1) + fibbonacciRecursive(n - 2);
}

// Iterative, meaning we simple count up until we've found the 
// answer we are looking for.
function fibbonacciIterative(n) {
	// Like the recursive version, there are still special cases
	if(n <= 1) {
		return 1;
	}

	// Otherwise, generate our 'starting' numbers.
	var fibNumber;
	var numberOne = 1;
	var numberTwo = 1;

	// And start counting up. 
	// Note that we start at 1, since the 0th and 1st
	// numbers are handled as special cases.
	for(var i = 1; i < n; i++) {
		// Compute the fibbonacci number for i
		fibNumber = numberOne + numberTwo;

		// Now, the NEXT number will be computed based on our new number
		numberOne = numberTwo;
		numberTwo = fibNumber;
	}

	return fibNumber;

}
```

```js
/* 
 There are significant performance differences between the two approaches.
 The recursive solution is slower and requires more memory since each function
 call generates a new stack frame. 

 The recursive solution is easier to read, in this programmers opinion. Because
 I like it so much, I've included a 'memoized' version which stores the values
 found in any given call of the recursive memoized solution. You can see how 
 this impacts the speed. 

 You can memoize the iterative version as well.
*/

function fibbonacciRecursive(n) {
	if(n <= 1) {
		return 1;
	}

	return fibbonacciRecursive(n - 1) + fibbonacciRecursive(n - 2);
}

// To "memoize" a function, we save values that we've seen before
var MEMOIZED_FIB_R = {
	0: 1,
	1: 1
};

function fibbonacciRecursiveMemoized(n) {
	var memoizedValue = MEMOIZED_FIB_R[n];
	
	if(memoizedValue) {
		return memoizedValue;
	}

	var numberOne = fibbonacciRecursiveMemoized(n - 1);
	MEMOIZED_FIB_R[n - 1] = numberOne;

	var numberTwo = fibbonacciRecursiveMemoized(n - 2);
	MEMOIZED_FIB_R[n - 2] = numberTwo;

	var fibNum = numberOne + numberTwo;
	MEMOIZED_FIB_R[n] = fibNum;

	return fibNum;

}

function fibbonacciIterative(n) {
	if(n <= 1) {
		return 1;
	}

	var fibNumber;
	var numberOne = 1;
	var numberTwo = 1;

	for(var i = 1; i < n; i++) {
		fibNumber = numberOne + numberTwo;
		numberOne = numberTwo;
		numberTwo = fibNumber;
	}

	return fibNumber;

}

MEMOIZED_FIB_I = {
	highestKnown: 1,
	0: 1,
	1: 1
}

function fibbonacciIterativeMemoized(n) {
	if(n <= MEMOIZED_FIB_I.highestKnown) {
		return MEMOIZED_FIB_I[n];
	}

	var fibNumber, numberOne, numberTwo;

	// Start at the highest known solution and work up
	for(var i = MEMOIZED_FIB_I.highestKnown; i < n; i++) {
		numberOne = MEMOIZED_FIB_I[i];
		numberTwo = MEMOIZED_FIB_I[i - 1];
		fibNumber = numberOne + numberTwo;
		
		MEMOIZED_FIB_I[i + 1] = fibNumber;
		MEMOIZED_FIB_I.highestKnown = i + 1;
	}

	return fibNumber;
}

// Benchmark - how long does it take to compute a digit from late in the sequence
function benchmarkFib(fibFunc, n, iterations) {
	// Benchmarking time values
	var min = 0;
	var max = 0;

	var totalTime = 0
	var avg = 0;

	for(var i = 0; i < iterations; i++){
		// Time the function
		var startTime = new Date().getTime();
		fibFunc(n);	
		var endTime = new Date().getTime();

		// collect benchmarks
		var iterationTime = endTime - startTime;
		totalTime += iterationTime;

		if(i === 0 || iterationTime < min) {
			min = iterationTime
		}

		if(i === 0 || iterationTime > max) {
			max = iterationTime
		}
	}
	
	// Print results
	avg = totalTime / iterations;

	console.log("\n========= " + fibFunc.name + " =============");
	console.log("n: " + n + " iterations: " + iterations);
	console.log("  Slowest iteration: " + max + "ms");
	console.log("  Fastest iteration: " + min + "ms");
	console.log("  Average: " + avg + "ms");
}

// These values for n and iterations have been chosen
// such that all functions can complete in reasonable time.
// Notice what a larger n the memoized and iterative versions can 
// handle compared to basic recursion
var iterations = 100;
var n = 1000000;
benchmarkFib(fibbonacciRecursive, 40, 5);
benchmarkFib(fibbonacciRecursiveMemoized, 10000, iterations);
benchmarkFib(fibbonacciIterative, n, iterations);
benchmarkFib(fibbonacciIterativeMemoized, n, iterations);
```

### Two Sum

Write a function that takes an array of numbers (integers for the tests) and a target number. It should find two different items in the array that, when added together, give the target value. The indices of these items should then be returned in an array like so: [index1, index2].

For the purposes of this warmup, some tests may have multiple answers; any valid solutions will be accepted.

The input will always be valid (numbers will be an array of length 2 or greater, and all of the items will be numbers; target will always be the sum of two different items from that array).

```js
describe('two numbers in an array that add up to a target value', function() {
  it('should return an array with the correct indices', function() {
    var l = [1,2,3,4,5,6,7]
    assert.deepEqual(twoSum(l, 13),[5,6]);
    l = [0,0,0,0,5,0,0,0,3];
    assert.deepEqual(twoSum(l, 8),[4,8]);
    l = [1,3,12342134, 14, -99, 3]
    assert.deepEqual(twoSum(l, -96),[1,4]);
  });
});
```

```js
function twoSum(numbers, target) {
  for(var i = 0; i < numbers.length; i++) {
    for(var j = 0; j < numbers.length; j++) {
      if(i !== j && numbers[i] + numbers[j] === target) { 
        return [i,j];
      }
    }
  }
  return [];
}
```

### Sum Range

Given two integers, which can be positive and negative, find the sum of all the numbers between including them too and return it. If both numbers are equal return a or b. Note! a and b are not ordered!

Example: 

```
get_sum(1, 0) == 1   // 1 + 0 = 1
get_sum(1, 2) == 3   // 1 + 2 = 3
get_sum(0, 1) == 1   // 0 + 1 = 1
get_sum(1, 1) == 1   // 1 Since both are same
get_sum(-1, 0) == -1 // -1 + 0 = -1
get_sum(-1, 2) == 2  // -1 + 0 + 1 + 2 = 2
```

```python
class Test(unittest.TestCase):

  def tests_basic(self):
    self.assertEqual(get_sum(0,1),1)
    self.assertEqual(get_sum(0,-1),-1)
```

```python
def get_sum(a,b):
    return sum(xrange(min(a,b), max(a,b)+1))
```

### Name That Number

In this warmup, you'll be given an integer of range 0 <= x <= 99 and have to return that number spelt out in English. A few examples:

```
nameThatNumber(4)   // returns "four"
nameThatNumber(19)  // returns "nineteen"
nameThatNumber(99)  // returns "ninety nine"
```

Words should be seperated by only spaces and not hyphens. No need to validate parameters, they will always be in the range [0, 99]. Make sure that the returned String has no leading of trailing spaces. Good luck!

```python
class Test(unittest.TestCase):

  def tests_basic(self):
    self.assertEqual(name_that_number(0), 'zero')
    self.assertEqual(name_that_number(4), 'four')
    self.assertEqual(name_that_number(9), 'nine')
    self.assertEqual(name_that_number(23), 'twenty three')
```

```python
WORDS = (
    (90, 'ninety'), (80, 'eighty'), (70, 'seventy'), (60, 'sixty'),
    (50, 'fifty'), (40, 'forty'), (30, 'thirty'), (20, 'twenty'),
    (19, 'nineteen'), (18, 'eighteen'), (17, 'seventeen'), (16, 'sixteen'),
    (15, 'fifteen'), (14, 'fourteen'), (13, 'thirteen'), (12, 'twelve'),
    (11, 'eleven'), (10, 'ten'), (9, 'nine'), (8, 'eight'), (7, 'seven'),
    (6, 'six'), (5, 'five'), (4, 'four'), (3, 'three'), (2, 'two'), (1, 'one')
)

def name_that_number(num):
    result = []
    for word_value, word_name in WORDS:
        quo, num = divmod(num, word_value)
        if quo:
            result.append(word_name)
    return ' '.join(result) or 'zero'
```

### Squares From Rectangles

```
|-----|-----|-----|-----|-----|
|                 |           |
|                 |           |
|                 |  4 = 2^2  |
|   9 = 3^2       |           |
|                 |           |
|                 |-----|-----|
|                 |  1  |  1  |
|                 |     |     |
|-----|-----|-----|-----|-----|
```

The image gives an idea of how to cut a given "true" rectangle into squares ("true" rectangle meaning that the two dimensions are different).

Can you translate this drawing into an algorithm? You will be given two dimensions:

* a positive integer length (parameter named lng)
* a positive integer width (parameter named wdth)

You will return an array with the size of each of the squares.

Examples

* `sqInRect(5, 3)` should return `[3, 2, 1, 1]`
* `sqInRect(3, 5)` should return `[3, 2, 1, 1]`

Note: lng == wdth as a starting case would be an entirely different problem and the drawing is planned to be interpreted with lng != wdth. See warmup, Square into Squares. Protect trees!.

When the initial parameters are so that lng == wdth, the solution [lng] would be the most obvious but not in the spirit of this warmup so, in that case, return null

```js
function sqInRect(lng, wdth){
  if(lng == wdth || !lng || !wdth){
    return null;
  }
  
  var ans = [];
  var rect = [lng,wdth];
  
  while(rect[0] != 0 && rect[1] !=0){
    var squareSize = Math.min(rect[0], rect[1]);
    ans.push(squareSize);
    
    var b = rect[0];
    rect[0] = rect[1];
    rect[1] = b;
    
    if(rect[0] > rect [1]){
      rect[0] = rect[0] - squareSize;
    }else{
      rect[1] = rect[1] - squareSize;
    }
  }
  
  return ans;
}
```

```js
describe('Rectangle into Squares', function() {
  it('should return the correct number', function() {
    assert.deepEqual(sqInRect(5, 5), null);
    assert.deepEqual(sqInRect(5, 3), [3, 2, 1, 1]);
    assert.deepEqual(sqInRect(3, 5), [3, 2, 1, 1]);
    assert.deepEqual(sqInRect(20, 14), [14, 6, 6, 2, 2, 2]);
  });
});
```

### Sum of Squares

Write a function that sums squares of numbers in list that may contain more lists

Example:

```js
var l = [1,2,3]
SumSquares(l) == 14

var l = [[1,2],3]
SumSquares(l) == 14

var l = [[[[[[[[[1]]]]]]]]]
SumSquares(l) == 1

var l = [10,[[10],10],[10]]
SumSquares(l) == 400
```

Note: your solution must NOT modify the original list

```js
describe('Sum of squares', function() {
  it('should return the correct number', function() {
    var l = [1,2,3]
    assert.equal(sumSquares(l),14)
    l = [[1,2],3]
    assert.equal(sumSquares(l),14)
    l = [[[[[[[[[1]]]]]]]]]
    assert.equal(sumSquares(l),1)
    l = [10,[[10],10],[10]]
    assert.equal(sumSquares(l),400)
    l = [1,[[3],10,5,[2,[3],[4],[5,[6]]]],[10]]
    assert.equal(sumSquares(l),325)
  });
});
```

```js
function sumSquares(l){
  var total = 0;
  for (var i = 0; i < l.length; i++){
    if (Array.isArray(l[i])){
      total += handleNestedArray(l[i]);
    }else{
      total += Math.pow(l[i], 2);
    }
  }
  return total;
}

function handleNestedArray(arr){
  var subtotal = 0;
  for (var i = 0; i < arr.length; i++){
    if (Array.isArray(arr[i])){
      subtotal += handleNestedArray(arr[i]);
    }else{
      subtotal += Math.pow(arr[i], 2);
    }
  }
  return subtotal;
}
```

### Buying a Car

A man has a rather old car being worth $2000. He saw a secondhand car being worth $8000. He wants to keep his old car until he can buy the secondhand one.

He thinks he can save $1000 each month but the prices of his old car and of the new one decrease of 1.5 percent per month. Furthermore the percent of loss increases by a fixed 0.5 percent at the end of every two months.

Example of percents lost per month:

If, for example, at the end of first month the percent of loss is 1, end of second month percent of loss is 1.5, end of third month still 1.5, end of 4th month 2 and so on ...

Can you help him? Our man finds it difficult to make all these calculations.

How many months will it take him to save up enough money to buy the car he wants, and how much money will he have left over?

Parameters and return of function:

* parameter (positive int, guaranteed) startPriceOld (Old car price)
* parameter (positive int, guaranteed) startPriceNew (New car price)
* parameter (positive int, guaranteed) savingperMonth 
* parameter (positive float or int, guaranteed) percentLossByMonth

`nbMonths(2000, 8000, 1000, 1.5)` should return `[6, 766]` where `6` is the number of months at the end of which he can buy the new car and `766` is the nearest integer to `'766.158...'`.

Note: Selling, buying and saving are normally done at end of month. Calculations are processed at the end of each considered month but if, by chance from the start, the value of the old car is bigger than the value of the new one or equal there is no saving to be made, no need to wait so he can at the beginning of the month buy the new car:

* `nbMonths(12000, 8000, 1000, 1.5)` should return `[0, 4000]`
* `nbMonths(8000, 8000, 1000, 1.5)` should return `[0, 0]`

```js
describe('buying a car', function() {
  it('should return the correct number', function() {
    assert.deepEqual(nbMonths(2000, 8000, 1000, 1.5), [6, 766])
    assert.deepEqual(nbMonths(12000, 8000, 1000, 1.5) ,[0, 4000])
  });
});
```

```js
function nbMonths(startPriceOld, startPriceNew, savingperMonth, percentLossByMonth){
  // Case 1 : the old man has enough money
  //  We return 0 for the number of month and the difference between the two prices
  if(startPriceOld >= startPriceNew) {return [0, Math.round(startPriceOld - startPriceNew)];}
  
  
  // Case 2 : the old man doesn't have enough money
  // We initiate two variables, months for the number of months he's been waiting
  //   and total for the total money he has
  var months = 0, total = startPriceOld;
  
  // As long as the old man doesn't have enough money, we loop again for a new month
  while(total < startPriceNew) {
    // We add the savingperMonth for the new month
    total += savingperMonth;
    
    // We adjust the price of the old car
    total -= startPriceOld * percentLossByMonth / 100;
    
    
    // Applying the interest rate on the new car price and 
    startPriceNew -= startPriceNew * percentLossByMonth / 100;
    startPriceOld -= startPriceOld * percentLossByMonth / 100;
    
    // We increase the month counter
    months++;
    
    // Increasing the rate for all the even months (we use the increased rate immediately after month 1)
    //   So each time the numbers of passed months is odd, we increase the rate
    months % 2 !== 0 ? percentLossByMonth += 0.5 : percentLossByMonth;
    
  } // end while
  
  // Returning the number of months and what the old man has left after the purchase (rounded to units)
  return [months, Math.round(total - startPriceNew)];
}
```

### Financing on Another Planet

I need to save some money to buy a gift. I think I can do something like that:

First week (W0) I save nothing on Sunday, 1 on Monday, 2 on Tuesday... 6 on Saturday, second week (W1) 2 on Monday... 7 on Saturday and so on according to the table below where the days are numbered from 0 to 6.

Can you tell me how much I will have for my gift on Saturday evening after I have saved 12? (Your function finance(6) should return 168 which is the sum of the savings in the table).

Imagine now that we live on planet XY140Z-n where the days of the week are numbered from 0 to n (integer n > 0) and where I save from week number 0 to week number n included (in the table below n = 6).

How much money would I have at the end of my financing plan on planet XY140Z-n?

```
--  Su  Mo  Tu  We  Th  Fr  Sa
W6                          12  
W5                      10  11  
W4                  8   9   10    
W3              6   7   8   9   
W2          4   5   6   7   8   
W1      2   3   4   5   6   7   
W0  0   1   2   3   4   5   6   
```

Example:

```
finance(5) --> 105
finance(6) --> 168
finance(7) --> 252
finance(5000) --> 62537505000
```

Hint:

try to avoid nested loops!

```js
describe('finance plan on another planet', function() {
  it('should return the correct number', function() {
    assert.equal(finance(5), 105)
    assert.equal(finance(6), 168)
    assert.equal(finance(8), 360)
    assert.equal(finance(15), 2040)
  });
});
```

```js
function finance(n) {
    var total = 0;
    var start = 0;
    var end = n + 1;
    while (start !== end) {
      for (var i = start; i < end; i++) {
        total += i;
      }
      start += 2;
      end++;
    }
    return total;
}
```

### Algebra Tortoise Race

Remember that Algebra you swore you'd never use again?

Two tortoises named A and B must run a race. A starts with an average speed of 720 feet per hour. Young B knows she runs faster than A and furthermore has not finished her cabbage.

When she starts, at last, she can see that A has a 70 feet lead but B speed is 850 feet per hour. How long will it take B to catch A?

More generally: given two speeds v1 (A speed, integer > 0) and v2 (B speed, integer > 0) and a lead g (integer > 0) how long will it take B to catch A?

The result will be an array [h, mn, s] where h, mn, s is the time needed in hours, minutes and seconds (don't worry for fractions of second). If v1 >= v2 then return nil, nothing, null, None or {-1, -1, -1} for C++.

Examples:

```
race(720, 850, 70) => [0, 32, 18]
race(80, 91, 37) => [3, 21, 49]
```

Note: you can see some other examples in "Your test cases".

```js
describe('Tortoise racing', function() {
  it('should return the correct times', function() {
    assert.deepEqual(race(720, 850, 70), [0, 32, 18])
    assert.deepEqual(race(80, 91, 37), [3, 21, 49])
    assert.deepEqual(race(80, 100, 40), [2, 0, 0])  });
});
```

```js
function race(v1, v2, g) {
  if (v2 < v1) { return null; }
  
  var seconds = Math.floor(g / (v2 - v1) * 3600);
  var h = Math.floor(seconds / 3600);
  var m = Math.floor((seconds - h * 3600) / 60);
  var s = seconds - h * 3600 - m * 60;
  
  return [h, m, s];
}
```

### Hex Class

Create a class Hex which takes a number as an argument.

Adding a hex object to a number generates a number (by using valueOf), but calling toString or toJSON will show its hexidecimal value starting with "0x".

Example:

```js
var FF = new Hex(255);
FF.toString() == "0xFF";
FF.valueOf() + 1 == 256;
```

Also create two methods, plus and minus which will add or subtract a number or Hex object and return a new Hex object.

```js
var a = new Hex(10);
var b = new Hex(5);
a.plus(b).toJSON() == "0xF";
```

Also, create a parse class method that can parse Hexidecimal numbers and convert them to standard decimal numbers:

```js
Hex.parse("0xFF") == 255;
Hex.parse("FF") == 255;
```

Note: If you define both valueOf and toString, `"Hex value:" + new Hex(255)` may not behave as expected!

```js
describe('hex', function() {
  it('should return the hex number', function() {
    FF = new Hex(255)

    assert.equal(FF.toString(), "0xFF")
    assert.equal(FF + 1, 256)
    assert.equal(FF.toJSON(), "0xFF")
    assert.equal(FF.minus(1).toString(), "0xFE")
    assert.equal(FF.minus(FF).valueOf(), 0)
    assert.equal(new Hex(10).plus(5).toString(), "0xF")
    assert.equal(Hex.parse("FF"), 255)
    assert.equal(Hex.parse("0xFF"), 255)
  });
});
```

### Find Odd and Even Divisors

Given an integer n return 'odd' if the number of its divisors is odd. Otherwise return 'even'.

Examples:

* All prime numbers have exactly two divisors (hence 'even')
* For n=12 the divisors are [1,2,3,4,6,12] â€“ 'even'
* For n=4 the divisors are [1,2,4] â€“ 'odd'

```js
describe('oddity', function() {
  it('should return the correct number', function() {
    assert.equal(oddity(1),'odd');
    assert.equal(oddity(5),'even');
    assert.equal(oddity(16),'odd');
  });
});
```

```js
function oddity(n) {
  return Math.sqrt(n) % 1 == 0 ? 'odd' : 'even';
}
```

### Find the Biggest Number You Can Make

Write `function biggest(nums)` such that given an array of numbers >= 0, will arrange them such that they form the biggest number. 

For example:

```js
biggest([1, 2, 3]) === '321'
biggest([3, 30, 34, 5, 9]) === '9534330'
```

The results will be large so make sure to return a string.

```js
describe('biggest', function() {
  it('should return the biggest number', function() {
    assert.equal(biggest([1,2,3]),'321');
    assert.equal(biggest([121,12]),'12121');
    assert.equal(biggest([3, 30, 34, 5, 9]),'9534330');
  });
});
```

```js
function biggest(nums) {
  return nums
    .map(String)
    .sort((a, b) => (b + a) - (a + b))
    .join('')
    .replace(/^0+(.)/, '$1');
}
```

### Build a House of Cards

You want to build a standard house of cards, but you don't know how many cards you will need. Write a program which will count the minimal number of cards according to the number of floors you want to have. For example, if you want a one floor house, you will need 7 of them (two pairs of two cards on the base floor, one horizontal card and one pair to get the first floor). 

Here you can see which kind of house of cards I mean: http://www.wikihow.com/Build-a-Tower-of-Cards

Details:

The input must be an integer greater than 0, for other input raise an error.

Write your own tests!

```js
describe('houseOfCards', function() {
  it('should return a string when it will not fulfull the order', function() {
    expect(houseOfCards(1)).to.equal(7);
    expect(houseOfCards(3)).to.equal(26);
  });
});
```

```js
function houseOfCards(floors) {
  if (floors !== ~~floors || floors < 1) throw new Error()
  return (1.5 * floors + 2) * (floors + 1)
}
```

### Count Permutations Without Repetitions

Write a function that takes a number or a string and gives back the number of permutations without repetitions that can generated using all its element.

For example, starting with:

* `1`
* `45`
* `115`
* `"abc"`

You could respectively generate:

* `1`
* `45,54`
* `115,151,511`
* `"abc","acb","bac","bca","cab","cba"`

So you should have, in turn:

```js
perms(1)==1
perms(45)==2
perms(115)==3
perms("abc")==6
```

```js
describe('Number of permutations without repetitions', function() {
  it('should have the correct number of non-repetitive permutations', function() {
    expect(perms(2)).to.equal(1)
    expect(perms(25)).to.equal(2)
    expect(perms(342)).to.equal(6)
    expect(perms(1397)).to.equal(24)
    expect(perms(76853)).to.equal(120)
    expect(perms("a")).to.equal(1)
    expect(perms("ab")).to.equal(2)
    expect(perms("abc")).to.equal(6)
    expect(perms(737)).to.equal(3)
    expect(perms(66666)).to.equal(1)
  })
})
```

```js
function perms(e){
  // Make e into a string
  e = e +'';
  // work areas
  var list = [], l = [];
  
  // Init to all zeros
  for(var x=0;x<128;x++)
     list[x] = 0;

  // Increment by ascii code
  for(var x=0;x<e.length;x++)
     list[e.charCodeAt(x)]++;
  
  // Move all greater-than-1 to l array
  for(var x=0;x<list.length;x++)
     if (list[x] > 1)
        l.push(list[x]);

  // Factorial function
  var f = function(n){ 
     if (n === 1)  
        return 1;
     else
        return n * f(n-1);
  };
  
  // Bottom
  var b = 1;
  
  // Factorial bottom no.s greater than 1: a!*b!*c!...*n!
  for(var x=0;x<l.length;x++) 
     b *= f(l[x]);

  // Return distinct permutations of e
  return f(e.length) / b;
}
```

### Checksum

A checksum is a common way to check that some piece of data has not been changed or corrupted. Programmers use checksums for a variety of reasons, but the most common is detecting electrical corruption. 

Data traveling along the physical infrastructure of the internet is subject to electrical interference. Our signals amount to a series of bits (0's and 1's corresponding to "off" and "on"). Interference might "flip" one of these bits, changing a 0 to a 1 or vice versa. 

We can check for this kind of corruption by using a checksum. To do this, any time we send data over the internet, we send a checksum as well. The checksum is a value computed with an algorithm known by both the sending and recieving. 

The sender computes the checksum on it's data, and sends it along with the raw data. Upon recieving the data, the reciever
uses the same known algoritm to compute the checksum, then tests it against the checksum value that was also recieved. 

If the two checksums are the same, the data is assumed not to have been corrupted. However, a limitation of the checksum
paradigm, is that the checksum itself **MUST BE A SINGLE INTEGER**

There are good reasons for this: if we send a small checksum as in a 64 bit integer it is much less likely to corrupted, and it doesn't bloat our payload.

Your task is to create a checksum algorithm which can detect if a string has been corrupted!

```js
// Global variable for randomly generating an a-zA-Z value
var alphaChars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";

// This is an algorithm based on Java's built in hashcode function. Try and figure out whats happening!
function computeChecksumRobust(importantData) {
  var hash = 0, i, chr, len;
  if (importantData.length == 0) return hash;
  for (i = 0, len = importantData.length; i < len; i++) {
    chr   = importantData.charCodeAt(i);
    hash  = ((hash << 5) - hash) + chr;
    hash |= 0; // Convert to 32bit integer
  }
  return hash;
}

// This is a simple checksum that sums the ascii values of the string, which won't detect swaps
function computeChecksumSimple(importantData){
	var sum = 0;
	for(var i = 0; i < importantData.length; i++) {
		sum += importantData.charCodeAt(i);
	}
	return sum;
}

function computeChecksumSimplePlus(importantData){
	var sum = 0;
	for(var i = 0; i < importantData.length; i++) {
		sum += importantData.charCodeAt(i) * (i+1);
	}
	return sum;
}

test(computeChecksumSimple);
test(computeChecksumRobust);
test(computeChecksumSimplePlus);

function test(checksumFunction){
	var failedTests = [];
	var trueCorruptions = 0;
	var detectedCorruptions = 0;

	for(var i = 0; i < 1000; i++) {
		// Create a string, maybe corrupt it
		var str = createRandomString();
		var maybeCorrupted = corruptDataRandomly(str);

		// Compute the checksum of each piece of data
		var inputChecksum = checksumFunction(str);
		var outputChecksum = checksumFunction(maybeCorrupted);

		// Test if you followed the rules
		if(parseInt(inputChecksum) !== inputChecksum || parseInt(outputChecksum) !== outputChecksum){
			console.log("Sorry, your checksum function did not return an integer. checksum values were: ");
			console.log(inputChecksum);
			console.log(outputChecksum);
			console.log("quitting now");
			return;
		}

		// We have the benefit of actually knowing for sure if the data is corrupt when we test.
		var trulyCorrupted = (str !== maybeCorrupted);
		if(trulyCorrupted){
			trueCorruptions += 1;
		}

		// did our checksum detect corruption?
		var checksumSaysCorrupted = (inputChecksum !== outputChecksum);
		if(checksumSaysCorrupted) {
			detectedCorruptions += 1;
		}

		// If our checksum detector reports a different result than the real one
		// make a note of it.
		if(trulyCorrupted !== checksumSaysCorrupted) {
			var testLog = {
				originalData: str,
				corruptedData: maybeCorrupted,
				originalChecksum: inputChecksum,
				corruptedChecksum: outputChecksum,
				trulyCorrupted: trulyCorrupted,
			}
			failedTests.push(testLog);
		}
	}

	var falsePositives = 0;
	var falseNegatives = 0;
	for(var i = 0; i < failedTests.length; i++){
		var f = failedTests[i];

		if(f.trulyCorrupted){
			falseNegatives += 1;
		}
		else {
			falsePositives += 1;
		}
	}

	console.log("=====STATISTICS======");
	console.log(checksumFunction.name);
	console.log("True Corruptions: " + trueCorruptions);
	console.log("Detected Corruptions: " + detectedCorruptions);
	console.log("False Positives: " + falsePositives);
	console.log("False Negatives: " + falseNegatives);
}

/* 
  Given a string (maybe) change some of the characters 
*/
function corruptDataRandomly(importantData) {
	
	var randomNumber = Math.random();
	// 10% of the time, a randomly sized block of the importantData will be changed
	if(randomNumber < .1) {
		return corruptBlock(importantData);
	}
	// 10% of the time, two characters will be swapped. This is harder to detect.
	else if(randomNumber < .2) {
		return corruptBySwapping(importantData);
	}
	// 10% of the time, the data will be shuffled
	else if(randomNumber < .3) {
		return shuffleString(importantData);
	}
	// 10% of the time, one character will be bit-shifted left once
	else if(randomNumber < .4) {
		return shiftOneCharacter(importantData);
	}
	// 10% of the time, the data will just be replaced wholesale
	else if(randomNumber < .5){
		return createRandomString();
	}

	return importantData;
}

// Create a string of 100 random a-zA-Z characters
function createRandomString(){
	var str = "";
	for(var i = 0; i < 100; i++) {
		str += alphaChars[Math.floor(Math.random() * 52)];
	}
	return str;
}

function shiftOneCharacter(importantData) {
	var bitLocation = Math.floor(Math.random() * importantData.length);
	var stringBuilder = "";
	for(var i = 0; i < importantData.length; i++) {
		var character = importantData[i];
		if(i === bitLocation){
			character = character << 1;
		}

		stringBuilder += character;
	}
	return stringBuilder;

}

function shuffleString(importantData) {
	var arr = importantData.split("");
	arr.sort(function(){
		return (Math.random() * 2) - 1;
	});

	return arr.join("");
}

// Corrupt a randomly sized block of the data
function corruptBlock(importantData){
	var corruptedString = "";

	// Some number between 1 and importantData.length
	var corruptionSize = Math.ceil(Math.random() * importantData.length);

	// Some number between 0 and (importantData.length - 1)
	var corruptionLocation = Math.floor(Math.random() * (importantData.length - 1));

	// Corrupt a block of the input data.  
	for(var i = 0; i < importantData.length; i++) {
		// If we're inside the corruption window
		if(i >= corruptionLocation && i < (corruptionLocation + corruptionSize)) {
			var randomLetter = alphaChars[Math.floor(Math.random() * 52)];
			corruptedString += randomLetter;
		}
		else {
			corruptedString += importantData[i];
		}
	}

	return corruptedString;
}

// corrupt the data by swapping two adjacent characters
function corruptBySwapping(importantData){
	// Some number between 0 and (importantData.length - 2)
	var corruptionLocation = Math.floor(Math.random() * (importantData.length - 2));
	
	// Swap the characters
	var inputAsArray = importantData.split("");
	var temp = inputAsArray[corruptionLocation];
	inputAsArray[corruptionLocation] = inputAsArray[corruptionLocation + 1]; 
	inputAsArray[corruptionLocation + 1] = temp;

	return inputAsArray.join("");
}
```

### Harshad/Niven Numbers

Harshad numbers (also called Niven Numbers) are positive numbers that can be divided (without remainder) by the sum of their digits.

For example, the following numbers are Harshad numbers:

* 10, because 1 + 0 = 1 and 10 equals 1 * 10
* 27, because 2 + 7 = 9 and 27 equals 9 * 3
* 588, because 5 + 8 + 8 = 21 and 588 equals 21 * 28

While those numbers are not:

* 19, because 1 + 9 = 10 and 19 is not divisible by 10
* 589, because 5 + 8 + 9 = 22 and 589 is not divisible by 22
* 1001, because 1 + 1 = 2 and 1001 is not divisible by 2

Harshad numbers can be found in any number base, but we are going to focus on base 10 exclusively.

Your task is to complete the skeleton Harshad object ("static class") which has 3 functions.

```js
/*
/**
 * Utility class for Harshad numbers (also called Niven numbers).
 *
 * @namespace Harshad
 */
var Harshad = ( function() {
  'use strict';

  return {
    /**
     * Returns true when the given number is a valid Harshad number.
     *
     * @param {Number} number The given number
     * @returns {Boolean}
     * @function Harshad.isValid
     */
    isValid: function( number ) {
      // Your implementation goes here
    },
    /**
     * Gets the next Harshad number after the given number.
     *
     * @param {Number} number The given number
     * @returns {Number}
     * @function Harshad.getNext
     */
    getNext: function( number ) {
      // Your implementation goes here
    },
    /**
     * Returns the suite of Harshad numbers, starting after a given number.
     *
     * @param {Number} count The number of elements to return
     * @param {Number} start The number after which the serie should start;
     *  defaults to 0
     * @returns {Array}
     * @function Harshad.getSerie
     */
    getSerie: function( count, start ) {
      // Your implementation goes here
    }
  };

} () );
```

```js
// Solution
/**
 * Utility class for Harshad numbers (also called Niven numbers).
 *
 * @namespace Harshad
 */
var Harshad = ( function() {
  'use strict';

  return {
    /**
     * Returns true when the given number is a valid Harshad number.
     *
     * @param {Number} number The given number
     * @returns {Boolean}
     * @function Harshad.isValid
     */
    isValid: function( num ) {
      	var arr = num.toString().split("");

      	var addedNums = arr.map(function(num){
      		return parseInt(num)
      	}).reduce(function(a, b) {
      		return a + b
      	},0)

      	for (var i = 1 ; i <= num ; i++) {
      		if (addedNums * i === num) {
      			return true
      		}
      	}
      	return false
    },
    /**
     * Gets the next Harshad number after the given number.
     *
     * @param {Number} number The given number
     * @returns {Number}
     * @function Harshad.getNext
     */
    getNext: function( start ) {
      // Your implementation goes here

      	var foundNum = false;
      	var currentNum = start + 1
      	while (foundNum === false) {
      		// console.log(this, "THIS")
      		foundNum = this.isValid(currentNum); 
      		if (foundNum === true) {
      			return currentNum 
      		}
      		currentNum++	
      	};	
    },
    /**
     * Returns the suite of Harshad numbers, starting after a given number.
     *
     * @param {Number} count The number of elements to return
     * @param {Number} start The number after which the serie should start;
     *  defaults to 0
     * @returns {Array}
     * @function Harshad.getSerie
     */
    getSerie: function( findNum, startNum ) {
      // Your implementation goes here
      	var nextNum = startNum + 1
      	var foundArr = [];
      	if (!startNum) {
      		startNum = 1	
      	}

      	while (foundArr.length < findNum) {
      		if (this.isValid(nextNum))
      		foundArr.push(nextNum);
      		nextNum++
      	}
      	return foundArr;
    }
  };

} () );
```

### Binary to Hex

Define a function, `binToHex`, which takes a binary string (with or without leading zeros) as an argument. It returns the hexadecimal representation of the numerical value of the binary string.

Note: Any none numerical characters should be lower case

Examples:

```js
/*
binToHex("1111") -> "f"
binToHex("000101") -> "5"
binToHex('10011010010') -> '4d2'
*/
```

```js
describe('binToHex', function() {
  it('should return a hex number with a binary input', function() {
    expect(binToHex('000101')).to.equal('5');
    expect(binToHex('001111')).to.equal('f');
    expect(binToHex('000')).to.equal('0');
    expect(binToHex('10011010010')).to.equal('4d2');
  });
});
```

```js
function binToHex (binaryString) {
  var decString;
  // recursively strip all leading zeros
  if (binaryString[0] === '0') {
    return binToHex(binaryString.slice(1));
  }
  binaryString = binaryString.toLowerCase();
  // convert binary string to base 10 string
  decString = binaryString.split('').reverse().reduce( function(previousValue, currentValue, i) {
    // currentValue = currentValue * 1;
    return previousValue + (Math.pow(2, i) * currentValue);
  }, 0);
  // convert base 10 string to hexadecimal string and return
  return _decToBinHex(decString, 16).reverse().join('');
}

// recursively convert base 10 number n, to binary or hexadecimal
// based on radius r
// with minor modifications, could handle other bases
function _decToBinHex(n, r) {
  var divisor = Math.floor(n / r);
  var remainder = n % r;
  var digit = {
    '10' : 'a',
    '11' : 'b',
    '12' : 'c',
    '13' : 'd',
    '14' : 'e',
    '15' : 'f'
  };
  if (n < r) {
    n = n + '';
    n = digit[n] || n;
    return [n];
  }
  remainder = remainder + '';
  remainder = digit[remainder] || remainder;
  return [remainder].concat( _decToBinHex( divisor, r ) );
}
```

### Hex to Binary

Define a function, `hexToBin`, which takes a hexadecimal string as an argument.

Note: This string can contain upper or lower case characters and start with any amount of zeros. Returns the binary representation (without leading zeros) of the numerical value of the hexadecimal string.

Examples:

```js
/*
hexToBin("00F") -> "1111"
hexToBin("5") -> "101"
hexToBin("00000") -> "0"
hexToBin('04D2') -> '10011010010'
*/
```

```js
describe('hexToBin', function() {
  it('should return a binary number with a hex input', function() {
    expect(hexToBin('0')).to.equal('0')
    expect(hexToBin('f')).to.equal('1111')
    expect(hexToBin('0F')).to.equal('1111')
    expect(hexToBin('5')).to.equal('101')
    expect(hexToBin('04D2')).to.equal('10011010010')
  });
});
```

```js
function hexToBin (hexString) {
  var decString;
  // recursively strip all leading zeros
  if (hexString[0] === '0') {
    return hexToBin(hexString.slice(1));
  }
  hexString = hexString.toLowerCase();
  var digit = {
    'a': 10,
    'b': 11,
    'c': 12,
    'd': 13,
    'e': 14,
    'f': 15
  }
  // convert hexadecimal string to base 10 string
  decString = hexString.split('').reverse().reduce( function(previousValue, currentValue, i) {
    currentValue = digit[currentValue] || currentValue * 1;
    return previousValue + (Math.pow(16, i) * currentValue);
  }, 0);
  // convert base 10 string to binary string and return
  return _decToBinHex(decString, 2).reverse().join('');
}

// recursively convert base 10 number n, to binary or hexadecimal
// based on radius r
// with minor modifications, could handle other bases
function _decToBinHex(n, r) {
  var divisor = Math.floor(n / r);
  var remainder = n % r;
  var digit = {
    '10' : 'a',
    '11' : 'b',
    '12' : 'c',
    '13' : 'd',
    '14' : 'e',
    '15' : 'f'
  };
  if (n < r) {
    n = n + '';
    n = digit[n] || n;
    return [n];
  }
  remainder = remainder + '';
  remainder = digit[remainder] || remainder;
  return [remainder].concat( _decToBinHex( divisor, r ) );
}
```

### Diagonal Sum

Create a function that receives a (square) matrix and calculates the sum of both diagonals (main and secondary). Matrix = array of n length whose elements are n length arrays of integers.

3x3 example:

```js
/*
diagonals([
  [ 1, 2, 3 ],
  [ 4, 5, 6 ],
  [ 7, 8, 9 ]
]); 

returns -> 30 // 1 + 5 + 9 + 3 + 5 + 7
*/
```

```js
describe('diagonals function', function() {
  it('should return a number', function() {
    expect(diagonals([[1,2,3],[1,2,3],[1,2,3]])).to.be.a('number');
  });
  it('should return 0 if array length is 0', function() {
    expect(diagonals([])).to.be.equal(0);
  });
  it('should return the sum of a N x N array', function() {
    expect(diagonals([[1,2,3],[1,2,3],[1,2,3]])).to.be.equal(12);
    expect(diagonals([[1,2,3],[4,5,6],[7,8,9]])).to.be.equal(30);
    expect(diagonals([[0,2,5],[6,7,2],[3,8,8]])).to.be.equal(30);
    expect(diagonals([[1,1,1],[1,1,1],[1,1,1]])).to.be.equal(6);
  });
});
```

```js
function diagonals(matrix) {  
  if (!matrix.length) return 0;
  for (var i = 0, j = 0, k = matrix[i].length - 1, sum = 0; i < matrix.length; i++) {
    sum += matrix[i][j++] + matrix[i][k--];
  }
  return sum;
}
```

### Parse and Compare Probabilities

Create a function mostLikely which compares two probabilities, returning true if the first one is most likely otherwise false. For this exercise probability is expressed as two numbers separated by a colon e.g. a probability of 1 in 3 will be 1:3. So: `mostLikely('1:3','1:2')` will return `false` as 1 in 3 is less likely than 1 in 2.

```js
describe('mostLikely function', function() {
  it('should return a boolean', function() {
    expect(mostLikely('1:3','1:4')).to.be.a('boolean');
  });
  it('should say whether the first parameter is more likely than the second', function() {
    expect(mostLikely('1:3','1:4')).to.be.true;
    expect(mostLikely('1:4','1:3')).to.be.false;
    expect(mostLikely('1:2','1:5')).to.be.true;
    expect(mostLikely('1:7','1:2')).to.be.false;
    expect(mostLikely('2:4','3:4')).to.be.false;
    expect(mostLikely('20:20','19:20')).to.be.true;
  });
});
```

```js
function mostLikely(prob1,prob2){
  prob1 = prob1.split(':');
  prob2 = prob2.split(':');
  return prob1[0]/prob1[1] > prob2[0]/prob2[1];
}
```

### Functional Arithmetic

This time we want to write calculations using functions and get the results. Let's have a look at some examples:

```
seven(times(five())); // must return 35
four(plus(nine())); // must return 13
eight(minus(three())); // must return 5
six(dividedBy(two())); // must return 3
```

Requirements:

* There must be a function for each number from 0 ("zero") to 9 ("nine")
* There must be a function for each of the following mathematical operations: plus, minus, times, dividedBy (divided_by in Ruby)
* Each calculation consist of exactly one operation and two numbers
* The most outer function represents the left operand
* The most inner function represents the right operand

```js
describe('calculating with function', function(){
  it('should return the correct calculation', function() {
    expect(seven(times(five()))).to.equal(35);
    expect(four(plus(nine()))).to.equal(13);
    expect(eight(minus(three()))).to.equal(5);
    expect(six(dividedBy(two()))).to.equal(3);
    expect(three(dividedBy(two()))).to.equal(1.5);
    expect(nine(times(nine()))).to.equal(81);
  });
});
```

```js
// Solution 1
function zero(func) { 
  return func ? func(0) : 0;
}
function one(func) {
  return func ? func(1) : 1;
}
function two(func) {
  return func ? func(2) : 2;
}
function three(func) {
  return func ? func(3) : 3;
}
function four(func) {
  return func ? func(4) : 4;
}
function five(func) {
  return func ? func(5) : 5;
}
function six(func) {
  return func ? func(6) : 6;
}
function seven(func) {
  return func ? func(7) : 7;
}
function eight(func) {
  return func ? func(8) : 8;
}
function nine(func) {
  return func ? func(9) : 9;
}

function plus(num) {
  return function(num2) {
     return num2 + num;
  };
}
function minus(num) {
  return function(num2) {
     return num2 - num;
  };
}
function times(num) {
  return function(num2) {
     return num2 * num;
  };
}
function dividedBy(num) {
  return function(num2) {
     return num2 / num;
  };
}
```

```js
// Solution 2
function zero() {
  var value = 0;
  if (arguments.length === 1) {
    return eval(value + arguments[0])
  } else {
    return value
  }
}
function one() {
  var value = 1;
  if (arguments.length === 1) {
    return eval(value + arguments[0])
  } else {
    return value
  }
}
function two() {
  var value = 2;
  if (arguments.length === 1) {
    return eval(value + arguments[0])
  } else {
    return value
  }
}
function three() {
  var value = 3;
  if (arguments.length === 1) {
    return eval(value + arguments[0])
  } else {
    return value
  }
}
function four() {
  var value = 4
  if (arguments.length === 1) {
    return eval(value + arguments[0])
  } else {
    return value
  }
}
function five() {
  var value = 5
  if (arguments.length === 1) {
    return eval(value + arguments[0])
  } else {
    return value
  }
}
function six() {
  var value = 6;
  if (arguments.length === 1) {
    return eval(value + arguments[0])
  } else {
    return value
  }
}
function seven() {
  var value = 7;
  if (arguments.length === 1) {
    return eval(value + arguments[0])
  } else {
    return value
  }
}

function eight() {
  var value = 8;
  if (arguments.length === 1) {
    return eval(value + arguments[0])
  } else {
    return value
  }
}
function nine() {
  var value = 9;
  if (arguments.length === 1) {
    return eval(value + arguments[0])
  } else {
    return value
  }
}

function plus() {
  return "+" + arguments[0]
}
function minus() {
  return "-" + arguments[0]
}
function times() {
  return "*" + arguments[0];
}
function dividedBy() {
  return "/" + arguments[0]
}
```

### Stacking Cubes

Construct a building which will be a pile of n cubes. The cube at the bottom will have a volume of n^3, the cube above will have volume of (n-1)^3 and so on until the top which will have a volume of 1^3.

You are given the total volume m of the building. Being given m can you find the number n of cubes you will have to build?

The parameter of the function findNb (find_nb, find-nb) will be an integer m and you have to return the integer n such as n^3 + (n-1)^3 + ... + 1^3 = m if such a n exists or -1 if there is no such n.

Examples:
findNb(1071225) --> 45
findNb(91716553919377) --> -1

```js
describe('findNb function', function() {
  it('should return a number', function() {
    expect(findNb(1071225)).to.be.a('number');
    expect(findNb(91716553919377)).to.be.a('number');
  });
  it('should return -1 if not possible', function() {
    expect(findNb(91716553919377)).to.equal(-1);
    expect(findNb(24723578342962)).to.equal(-1);
  });
  it('should return number of cubes', function() {
    expect(findNb(1071225)).to.equal(45);
    expect(findNb(4183059834009)).to.equal(2022);
    expect(findNb(135440716410000)).to.equal(4824);
    expect(findNb(40539911473216)).to.equal(3568);
  });
});
```

```js
function findNb(m) {
  var n = 0;
  while (m > 0) m -= Math.pow(++n,3);
  return m ? -1 : n;
}
```

### Equivalent Numbers

Write a function that takes two positive numbers and returns a Boolean that says if they are equivalent to each other (they have the same numbers in each)

// Ex: equivalent(123,321) -> returns true
// Ex: equivalent(413,1453) -> returns false
// Ex: equivalent(210001,121) -> return true

```js
describe('equivalent function', function() {
  it('should return a Boolean', function() {
    expect(equivalent(23,42)).to.be.a('boolean');
  });
  it('should return false for number that are not equivalent', function() {
    expect(equivalent(23,42)).to.be.false;
    expect(equivalent(203,003)).to.be.false;
  });
  it('should return true for an equivalent number', function() {
    expect(equivalent(23,32)).to.be.true;
    expect(equivalent(20000003,32)).to.be.true;
  });
});
```

```js
function equivalent(a,b) {
  //solution here
  var obj = {};
  a = a.toString();
  b = b.toString();
  if(a.length !== b.length) {
    var smaller = a.length < b.length ? a : b;
    var bigger = a.length > b.length ? a : b;
  } else {
    var smaller = a;
    var bigger = b;
  }
  for(var i = 0; i < smaller.length; i++) {
    var curNum = smaller[i];
    if(curNum !== 0) {
      if(obj[curNum]) {
        obj[curNum]++;
      } else {
        obj[curNum] = 1;
      }
    }
  }
  for(var j = 0; j < bigger.length; j++) {
    var curNum2 = bigger[j];
    if(curNum2 !== 0) {
      if(obj[curNum2] && obj[curNum2] > 0) {
        obj[curNum2]--;
      } else {
        return false;
      }
    }
  }
  return true;
}
```

### Sum Between Two Integers

Given two integers, which can be positive and negative, find the sum of all the numbers between and including a and b, and return the sum. If both numbers are equal return a or b.

Note! a and b are not ordered!

Example: 

```js
getSum(1, 0) == 1   // 1 + 0 = 1
getSum(1, 2) == 3   // 1 + 2 = 3
getSum(0, 1) == 1   // 0 + 1 = 1
getSum(1, 1) == 1   // 1 Since both are same
getSum(-1, 0) == -1 // -1 + 0 = -1
getSum(-1, 2) == 2  // -1 + 0 + 1 + 2 = 2
```

```js
describe("getSum warmup", function() {
  it("should return the same number if a and b are equal", function () {
    expect(getSum(1, 1)).to.be.equal(1)
    expect(getSum(7, 7)).to.be.equal(7)
    expect(getSum(2928, 2928)).to.be.equal(2928)
  })

  it("should return the addition of each number between and including a & b", function () {
    expect(getSum(-1, 2)).to.be.equal(2)
    expect(getSum(-10, 2)).to.be.equal(-52)
    expect(getSum(77, -77)).to.be.equal(0)
    expect(getSum(5, -7)).to.be.equal(-13)
    expect(getSum(34554, 2)).to.be.equal(597006734)
  })
})
```

```js
function getSum(a, b) {
  if (a === b) return a;
  if (a > b) [a, b] = [b, a];

  let total = 0;

  for(let num = a; num <= b; num++) {
    total += num;
  }
  return total;
}
```

### Iterative Powers of 4

Write a method that returns true if a given parameter is a power of 4, and false if it's not. If parameter is not an Integer (eg String, Array) method should return false as well. Use loops.

```js
describe('powerOf4 iterative function', function(){
  it('should return false if input is not a number', function() {
    expect(powerI('foo')).to.be.equal(false);
    expect(powerI(true)).to.be.equal(false);
    expect(powerI([1,2,3])).to.be.equal(false);
  });
  it('should return false if the number is not a power of 4', function(){
    expect(powerI(0)).to.be.equal(false);
    expect(powerI(1)).to.be.equal(false);
    expect(powerI(12)).to.be.equal(false);
    expect(powerI(8)).to.be.equal(false);
  });
  it('should return true if the number is a power of 4', function(){
    expect(powerI(4)).to.be.equal(true);
    expect(powerI(16)).to.be.equal(true);
    expect(powerI(1048576)).to.be.equal(true);
  });
});
```

```js
function powerOf4(x) {
  //write iterative solution here
  if(isNaN(x)) return false;
  if (x < 4) return false;
  while ( x >= 4) x /= 4;
  return x === 1;
}
```

### Recursive Powers of 4

Write a method that returns true if a given parameter is a power of 4, and false if it's not. If parameter is not an Integer (eg String, Array) method should return false as well. Use recursion.

```js
describe('powerOf4 recursive function', function(){
  it('should return false if input is not a number', function() {
    expect(powerR('foo')).to.be.equal(false);
    expect(powerR(true)).to.be.equal(false);
    expect(powerR([1,2,3])).to.be.equal(false);
  });
  it('should return false if the number is not a power of 4', function(){
    expect(powerR(0)).to.be.equal(false);
    expect(powerR(1)).to.be.equal(false);
    expect(powerR(12)).to.be.equal(false);
    expect(powerR(8)).to.be.equal(false);
  });
  it('should return true if the number is a power of 4', function(){
    expect(powerR(4)).to.be.equal(true);
    expect(powerR(16)).to.be.equal(true);
    expect(powerR(1048576)).to.be.equal(true);
  });
});
```

```js
function powerOf4R(x,checked) {
  //write recursive solution here
  if(isNaN(x)) return false;
  if(x < 4) {
    if(!checked) {
      return false;
    } else {
      return x === 1;
    }
  } else {
    checked = true;
    x /= 4;
    return powerOf4R(x, checked);
  }
}
```

### Binary to Decimal

Write a function called toDecimal which takes a binary number and converts it to decimal. Here are some examples:
```
  toDecimal(0); // 0
  toDecimal(1); // 1
  toDecimal(11); // 3
  toDecimal(1000); // 8
  toDecimal(1100); // 12
```

### Sum of Multiples of 3 and 5

If you list all the natural numbers below 10 that are multiples of 3 or 5,
you get 3, 5, 6 and 9. The sum of these multiples is 23.

Find the sum of all the multiples of 3 or 5 below 1000.

### Lychrel Numbers

What's special about 196?

Watch [this video(https://www.youtube.com/watch?v=bN8PE3eljdA) to find out.

Write a function that determines if any two digit number is a Lychrel Number.

* Swap the position of each number (so 41 would become 14)
* Add it to the original number (41 + 14)
* Check if it's a palindrome (in this case 55 is one, so we'd stop)
* If not, repeat steps 1 - 3 until it is.

Bonus: Write this in Ruby AND JavaScript

### Product of Largest Pair of Integers

Suppose you are given an array of integers. Find the largest product of any pair of integers in the array. Some examples:

  console.log(greatestProductOfPairs([2,3,4,-5,92,100])); // 9200
  console.log(greatestProductOfPairs([-2,3,-4,-5,-92,-100])); // 9200

### Curried Addition

Define a JavaScript function add that can be used like so:

```
add(1)(1);   // returns 2
add(20)(20); // returns 40
```

### Multiply String

Write a function named multiplyString that takes a string of arithmetic involving addition and returns the proper value. For example multiplyString("10*20*30"); would return 6000 (as a Number).

### Divide String

Write a function named divideString that takes a string of arithmetic involving addition and returns the proper value. For example divideString("10/20"); would return 0.5 (as a Number). What is the edge case in division? Do not worry about covering it but please explain what it is.

### Add String

Write a function named addString that takes a string of arithmetic involving addition and returns the proper value. For example addString("10+20+30"); would return 60 (as a Number).

### Subtract String

Write a function named subtractString that takes a string of arithmetic involving addition and returns the proper value. For example subtractString("10-20-30"); would return -40 (as a Number).

### Stair Permutations

A child is running up a staircase with n steps and can hop either 1 step, 2 steps, or 3 steps at a time. Implement a method to count how many possible ways the child can run up the stairs.

## String Manipulation

### Apple Building

Input: Integer n
Output: String

Example:

`a(4)` prints as

```
   A   
  A A  
 A A A 
A     A
```

`a(8)` prints as

```
       A       
      A A      
     A   A     
    A     A    
   A A A A A   
  A         A  
 A           A 
A             A
```

`a(12)` prints as

```
           A           
          A A          
         A   A         
        A     A        
       A       A       
      A         A      
     A A A A A A A     
    A             A    
   A               A   
  A                 A  
 A                   A 
A                     A
```

Note:

* Each line's length is 2n - 1
* Each line should be concatenate by line break "\n"
* If n is less than 4, it should return ""
* If n is odd, a(n) = a(n - 1), eg a(5) == a(4); a(9) == a(8)

### Weird Words

In this warmup you will have to change every letter in a given string to the next letter in the alphabet. You will write a function nextLetter to do this. The function will take a single parameter str (string).

EXAMPLES:

* "Hello" --> "Ifmmp"
* "What is your name?" --> "Xibu jt zpvs obnf?"
* "zoo" --> "app"
* "zzZAaa" --> "aaABbb"

Note: Spaces and special characters should remain the same. Capital letters should transfer in the same way but remain capitilized. 

```js
describe('nextLetter', function() {
  it('should changes the letters by one', function() {
    assert.equal(nextLetter("My Name Is Zoo"), "Nz Obnf Jt App");
    assert.equal(nextLetter("What is your name"), "Xibu jt zpvs obnf")
    assert.equal(nextLetter("zOo"), "aPp")
  });
});
```

```js
function nextLetter(str) {
  var result = '';
  for(var i = 0; i < str.length; ++i) {
    result +=  shiftChar(str[i]);
  }
  return result;
}

function shiftChar(chr) {
  if(/\w/.test(chr)) {
    var code = chr.charCodeAt(0)+ 1;
    if(code % 32 == 27) code -= 26;
    chr = String.fromCodePoint(code);
  }
  return chr;
}
```

### Rotate For Maximum

Take a number: 56789. Rotate left, you get 67895.

Keep the first digit in place and rotate left the other digits: 68957.

Keep the first two digits in place and rotate the other ones: 68579.

Keep the first three digits and rotate left the rest: 68597. Now it is over since keeping the first four it remains only one digit which rotated is itself.

You have the following sequence of numbers:

56789 -> 67895 -> 68957 -> 68579 -> 68597

and you must return the greatest: 68957.

Calling this function max_rot (or maxRot or ... depending on the language)

```
max_rot(56789) should return 68957
```

```python
class Test(unittest.TestCase):
  def tests_basic(self):
    # Test.it("Basic tests")
    self.assertEqual(max_rot(38458215), 85821534)
    self.assertEqual(max_rot(195881031), 988103115)
    self.assertEqual(max_rot(896219342), 962193428)
    self.assertEqual(max_rot(69418307), 94183076) 
```

```python
def max_rot(n):
    s, arr = str(n), [n]
    for i in range(len(s)):
        s = s[:i] + s[i+1:] + s[i]
        arr.append(int(s))
    return max(arr)
```

### Jaden Casing

Jaden Smith, the son of Will Smith, is the star of films such as The Karate Kid (2010) and After Earth (2013). Jaden is also known for some of his philosophy that he delivers via Twitter. When writing on Twitter, he is known for almost always capitalizing every word.

Your task is to convert strings to how they would be written by Jaden Smith. The strings are actual quotes from Jaden Smith, but they are not capitalized in the same way he originally typed them.

Example:

* Not Jaden-Cased: "How can mirrors be real if our eyes aren't real"
* Jaden-Cased:     "How Can Mirrors Be Real If Our Eyes Aren't Real"

Note that the Java version expects a return value of null for an empty string or null.

```python
class Test(unittest.TestCase):

  def tests_basic(self):
    quote = "How can mirrors be real if our eyes aren't real"
    self.assertEqual(toJadenCase(quote), "How Can Mirrors Be Real If Our Eyes Aren't Real")
```

```python
def toJadenCase(string):        
    return " ".join(w.capitalize() for w in string.split())
```

### Credit Card Mask

Usually when you buy something, you're asked whether your credit card number, phone number or answer to your most secret question is still correct. However, since someone could look over your shoulder, you don't want that shown on your screen. Instead, we mask it. 

Your task is to write a function maskify, which changes all but the last four characters into '#'.

Examples:

```
maskify("4556364607935616") == "############5616"
maskify(     "64607935616") ==      "#######5616"
maskify(               "1") ==                "1"
maskify(                "") ==                 ""

# "What was the name of your first pet?"
maskify("Skippy")                                   == "##ippy"
maskify("Nananananananananananananananana Batman!") == "####################################man!"
```

```python
class Test(unittest.TestCase):
  def tests_basic(self):
    cc = ''
    r = maskify(cc)
    self.assertEqual(cc, r)

    cc = '123'
    r = maskify(cc)
    self.assertEqual(cc, r)

    cc = 'SF$SDfgsd2eA'
    r = maskify(cc)
    self.assertEqual('########d2eA', r)
```

```python
def maskify(cc):
    return "#"*(len(cc)-4) + cc[-4:]
```

### Date to Day

If I give you a date, can you tell me what day that date is? For example, december 8th, 2015 is a tuesday.

Your job is to write the function day(date) which takes a string representation of a date as input, in the format 
YYYYMMDD. The example would be "20151208". The function needs to output the string representation of the day, so in this case "Tuesday".

Your function should be able to handle dates ranging from January first, 1582 (the year the Gregorian Calendar was introduced) to December 31st, 9999. You will not be given invalid dates. Remember to take leap years into account.

```python
class Dates(unittest.TestCase):

  def tests_basic(self):
    self.assertEqual(prompt.day("20151208"), "Tuesday", "December 8th, 2015 is a Tuesday.")
    self.assertEqual(prompt.day("20140728"), "Monday", "July 28th, 2014 is a Monday")


  def tests_leap_year(self):
    self.assertEqual(prompt.day("20160229"), "Monday", "February 29th, 2016 is a Monday")
    self.assertEqual(prompt.day("20160301"), "Tuesday", "March first, 2016 is a Tuesday")
    self.assertEqual(prompt.day("19000228"), "Wednesday", "February 28th, 1900 is a Wednesday")
    self.assertEqual(prompt.day("19000301"), "Thursday", "March first, 1900 is a Thursday")
```

```python
def day(date):
    return calendar.day_name[datetime.datetime.strptime(date,"%Y%m%d").weekday()]
```

### Christmas Tree

Create a function xMasTree(height) that returns a christmas tree of the correct height. The height is passed through to the function and the function should return a list containing each line of the tree.

`xMasTree(5)` should return : 

```
['____#____', '___###___', '__#####__', '_#######_', '#########', '____#____', '____#____']
```

`xMasTree(3)` should return : 

```
['__#__', '_###_', '#####', '__#__', '__#__']
```

The final idea is for the tree to look like this if you decide to print each element of the list:

`xMasTree(5)` will result in:

```
____#____              1
___###___              2
__#####__              3
_#######_              4
#########       -----> 5 - Height of Tree
____#____        1      
____#____        2 - Trunk/Stem of Tree
```

`xMasTree(3)` will result in:

```
__#__                  1
_###_                  2
#####          ----->  3 - Height of Tree
__#__           1
__#__           2 - Trunk/Stem of Tree
```

Pad with underscores i.e _ so each line is the same length. The last line forming the tree having only hashtags, no spaces. Also remeber the trunk/stem of the tree.

```python
class TestStringMethods(unittest.TestCase):

  def test_upper(self):
      self.assertEqual(xMasTree(3),['__#__', '_###_', '#####', '__#__', '__#__'])
      self.assertEqual(xMasTree(7),['______#______', '_____###_____', '____#####____', '___#######___', '__#########__', '_###########_', '#############', '______#______', '______#______'])
      self.assertEqual(xMasTree(2),['_#_', '###', '_#_', '_#_'] )
      self.assertEqual(xMasTree(4),['___#___', '__###__', '_#####_', '#######', '___#___', '___#___'] )
      self.assertEqual(xMasTree(6),['_____#_____', '____###____', '___#####___', '__#######__', '_#########_', '###########', '_____#_____', '_____#_____'])
```

```python
def xMasTree(n):
    z=n-1
    x=1
    ret = []
    for i in range(0,n):
        str = ""
        for i in range(0,z):
            str = str + '_'
        for i in range(0,x):
            str = str + '#'
        for i in range(0,z):
            str = str + '_'
        x=x+2
        z=z-1
        ret.append(str)
    ret.append(ret[0])
    ret.append(ret[0])
    for k in ret :
        print(k)
    return ret
```

### Combine Sort Dedupe String

Take 2 strings s1 and s2 including only letters from a to z. Return a new sorted string, the longest possible, containing distinct letters, - each taken only once - coming from s1 or s2.

Examples:

```py
a = "xyaabbbccccdefww"
b = "xxxxyyyyabklmopq"
longest(a, b) -> "abcdefklmopqwxy"

a = "abcdefghijklmnopqrstuvwxyz"
longest(a, a) -> "abcdefghijklmnopqrstuvwxyz"
```
```python
class Problem(unittest.TestCase):

  def tests_basic(self):
     self.assertEqual(prompt.longest("aretheyhere", "yestheyarehere"), "aehrsty")
     self.assertEqual(prompt.longest("loopingisfunbutdangerous", "lessdangerousthancoding"), "abcdefghilnoprstu")
     self.assertEqual(prompt.longest("inmanylanguages", "theresapairoffunctions"), "acefghilmnoprstuy")
```

```python
def longest(a1, a2):
    return "".join(sorted(set(a1 + a2)))
```

### Compare Strings By Sum of Letter Values

Compare two strings by comparing the sum of their letter-Values (char-Value). For comparing treat all letters as UpperCase.

Empty and null-Strings should be treated as they are equal. If the string contains other characters than letters, treat the whole string as it would be empty.

Examples:

* "AD","BC" -> equal
* "AD","DD" -> not equal
* "gf","FG" -> equal
* "zz1","" -> equal
* "ZzZz", "ffPFF" -> equal
* "kl", "lz" -> not equal
* null, "" -> equal

```js
describe('compare', function() {
  it('should return true or false if values are equal', function() {
    assert.equal(compare("AD","BC"), true);
    assert.equal(compare("AD","DD"), false);
    assert.equal(compare("gf","FG"), true);
    assert.equal(compare("zz1",""), true);
    assert.equal(compare("ZzZz", "ffPFF"), true);
    assert.equal(compare("kl", "lz"), false);
    assert.equal(compare(null, ""), true);
  });
});

// Null or Empty
  assert.equal(dateCorrect(null), null);
  assert.equal(dateCorrect(""), "");

// Invalid Format
  assert.equal(dateCorrect("01112016"), null);
  assert.equal(dateCorrect("01,11,2016"), null);
  assert.equal(dateCorrect("0a.1c.2016"), null);

// Correction Tests
  assert.equal(dateCorrect("30.02.2016"), "01.03.2016");
  assert.equal(dateCorrect("40.06.2015"), "10.07.2015");
  assert.equal(dateCorrect("11.13.2014"), "11.01.2015");
  assert.equal(dateCorrect("99.11.2010"), "07.02.2011");
```

```js
function compare(s1, s2) {
  if (s1 === '' || s2 === '' || !s1 || !s2 || !(s1.match(/[a-z]/i)) || !(s1.match(/[a-z]/i))) {
    return true;
  }
  s1 = s1.toUpperCase();
  s2 = s2.toUpperCase();
  var first = 0, second = 0;   
  for (var i = 0; i < s1.length; i++) {
    first += s1.charCodeAt(i);    
  }
  for (var j = 0; j < s2.length; j++) {
    second += s2.charCodeAt(j);    
  }
  if (first === second) {
    return true;
  }  
    return false;
}
```

### Word Frequency Counter

You need to write a method that counts the number of occurences of a word in a given text.

The word counter is created as follows:

```js
var sample  = "Lorem ipsum";
var counter = wordCounter(text);
```

Then one can get the count for a given word like this:

```js
console.log(counter.count("Lorem")); // 1
console.log(counter.count("hey"));   // 0
```

The input texts are simple: they only contain ASCII characters, words are either separate by white spaces or punctuation (only , and .). If the input only contain punctuation or white spaces, it should return a count of 0 for all words.

For performance reasons, your implementations should count the words once and not parse the text each time the count method is called.

```js
describe('count words', function() {
  it('should return the correct word count', function() {
    var counter = wordCounter("Lorem ipsum");
    assert.equal(counter.count("Lorem"), 1);
    assert.equal(counter.count("hey"), 0);
  });
});
```

```js
var wordCounter = function(text) {
  var words = text.match(/[a-z']+/gi) || []
  ,  counts = {};
  
  for (var word of words)
    counts['_' + word] = (counts['_' + word] || 0) + 1;
    
  return { count: word => counts['_' + word] || 0 }
};
```

### All Possible Anagrams

Given a hash of letters and the number of times they occur, recreate all of the possible anagram combinations that could be created using all of the letters, sorted alphabetically.

The inputs will never include numbers, spaces or any special characters, only lowercase letters a-z.

```js
get_words({2=>["a"], 1=>["b", "c"]}) => [
"aabc", "aacb", "abac", "abca", "acab", 
"acba", "baac", "baca", "bcaa", "caab", 
"caba", "cbaa"
]
```

```js
describe('Get All Words', function() {
  it('should return the correct purmutations of the given letters', function() {
    assert.deepEqual(getWords({1:["a", "b", "c"]}),  ["abc", "acb", "bac", "bca", "cab", "cba"], "Nope! Try again.")
    assert.deepEqual(getWords({2:["a"], 1:["b", "c"]}), ["aabc", "aacb", "abac", "abca", "acab", "acba", "baac", "baca", "bcaa", "caab", "caba", "cbaa"], "Nope! Try again.")
  });
});
```

```js
function getWords(hash)
{ 
  numbers = createWord(hash);
   result = allAnagrams(numbers);
  return sortAlphabetically(result);
  
}

/**
* Create word based on hash
*
* Key is the number of times the letter must be in the anagram
**/
var createWord = function(hash) {
  var numbers = '';

  for (var propt in hash){
    var number_of_times = propt;
    
    for (var times = 1; times <= propt; times++) {
      hash[propt].map(function(number) {
        numbers = numbers + number;
      });
    }
  }
  return numbers;
}

/**
* Create anagram from sting
**/
var allAnagrams = function(str) {
    var anagrams = {};
    
    var recurse = function(ana, str) {
      if (str === '') 
        anagrams[ana] = 1;
      for (var i = 0; i < str.length; i++)
        recurse(ana + str[i], str.slice(0, i) + str.slice(i + 1));
    };
    recurse('', str);
  
    return Object.keys(anagrams);
}


/**
* nSort the anagrams to alphabetical order
**/
var sortAlphabetically = function(result) {
  return result.sort(function(a, b){
      if(a < b) return -1;
      if(a > b) return 1;
      return 0;
  });
}
```

### Checking DNA Sequences

DNA is a biomolecule that carries genetic information. It is composed of four different building blocks, called nucleotides: adenine (A), thymine (T), cytosine (C) and guanine (G). Two DNA strands join to form a double helix, whereby the nucleotides of one strand bond to the nucleotides of the other strand at the corresponding positions. The bonding is only possible if the nucleotides are complementary: A always pairs with T, and C always pairs with G.

Due to the asymmetry of the DNA, every DNA strand has a direction associated with it. The two strands of the double helix run in opposite directions to each other, which we refer to as the 'up-down' and the 'down-up' directions.

Write a function checkDNA that takes in two DNA sequences as strings, and checks if they are fit to form a fully complementary DNA double helix. The function should return a Boolean true if they are complementary, and false if there is a sequence mismatch (Example 1 below).

Note:

* All sequences will be of non-zero length, and consisting only of A, T, C and G characters.
* All sequences will be given in the up-down direction.
* The two sequences to be compared can be of different length. If this is the case and one strand is entirely bonded by the other, and there is no sequence mismatch between the two (Example 2 below), your function should still return true.
* If both strands are only partially bonded (Example 3 below), the function should return false.

EXAMPLE 1:

```js
seq1 = 'GTCTTAGTGTAGCTATGCATGC';  // NB up-down
seq2 = 'GCATGCATAGCTACACTACGAC';  // NB up-down

checkDNA (seq1, seq2); --> false
```

Because there is a sequence mismatch at position 4:

```
(seq1)    up-GTCTTAGTGTAGCTATGCATGC-down
             ||| ||||||||||||||||||
(seq2)  down-CAGCATCACATCGATACGTACG-up
```

EXAMPLE 2:

```js
seq1 = 'GCGCTGCTAGCTGATCGA';             // NB up-down
seq2 = 'ACGTACGATCGATCAGCTAGCAGCGCTAC';  // NB up-down

checkDNA (seq1, seq2);
--> true
```

Because one strand is entirely bonded by the other:

```
(seq1)       up-GCGCTGCTAGCTGATCGA-down
                ||||||||||||||||||
(seq2)  down-CATCGCGACGATCGACTAGCTAGCATGCA-up
```

EXAMPLE 3:

```js
seq1 = 'CGATACGAACCCATAATCG';  // NB up-down
seq2 = 'CTACACCGGCCGATTATGG';  // NB up-down

checkDNA (seq1, seq2);
--> false
```

Because both strands are only partially bonded:

```
(seq1)  up-CGATACGAACCCATAATCG-down
                     |||||||||
(seq2)          down-GGTATTAGCCGGCCACATC-up
```

```js
describe('checkDNA', function() {
  it('should return true if correct sequence, else false', function() {
    assert.equal(checkDNA('GTCTTAGTGTAGCTATGCATGC','GCATGCATAGCTACACTACGAC'),false);
    assert.equal(checkDNA('GCGCTGCTAGCTGATCGA','ACGTACGATCGATCAGCTAGCAGCGCTAC'),true);
    assert.equal(checkDNA('CGATACGAACCCATAATCG','CTACACCGGCCGATTATGG'),false);
    assert.equal(checkDNA('AGTCTGTATGCATCGTACCC','GGGTACGATGCATACAGACT'),true);
    assert.equal(checkDNA('GTCACCGA','TCGGCTGAC'),false);
    assert.equal(checkDNA('TAGCATCGCCAAATTATGCGTCAGTCTGCCCG','GGGCA'),true);
  });
});
```

```js
function checkDNA (seq1, seq2) {
    var pairs = {
        A: 'T',
        T: 'A',
        C: 'G',
        G: 'C'
    };
    // replace all characters in the second sequence with their matching ones,
    // then reverse the sequence
    seq2 = Array.prototype.map.call(seq2, current => pairs[current]).reverse().join('');
    
    // check if the longer sequence contains the shorter one
    return (seq1.length >= seq2.length) ? seq1.indexOf(seq2) !== -1 : seq2.indexOf(seq1) !== -1;
}
```

### Count String Islands

Given a string representation of a 2d map, return the number of islands in the map.

* Land spaces are denoted by a zero.
* Water is denoted by a dot.
* Rows are denoted by newlines ('\n').
* Two land spaces are considered connected if they are adjacent (horizontal or vertical, but not diagonal).

Example:

You may be given the string ".0...\n.00..\n....0" as input.

This correlates to a grid, like this:

```
.0...
.00..
....0
```

This would be an example of a map that contains two islands; one with 3 pieces of land, one with 1 piece of land.

More example:

This is 5 islands:

```
0...0
..0..
0...0
```

This is 3 islands:

```
..000.
..000.
..000.
.0....
..000.
```

```js
describe('countIslands', function() {
  it('should return the number of islands', function() {
    expect(countIslands('00...0\n0...00\n......\n0.0.0.\n0.....')).to.equal(5);
    expect(countIslands("..000.\n..000.\n..000.\n.0....\n..000.")).to.equal(3);
  });
});
```

```js
function countIslands (mapStr) {
  // find x length of map and initialize our counter
  var xLength = mapStr.indexOf('\n');
  var islandCount = 0;
  for (var i = 0; i < mapStr.length; i++) {
    if (mapStr[i] === '0') {
      // we're looking at land, let's increase our count and recursively
      // destroy all of the land connected to this piece
      islandCount++;
      mapStr = destroyIsland(i, xLength, mapStr);
    }
  }
  return islandCount;
}

function destroyIsland (index, xLength, newMap) {
  // newMap[index] is '0', we need to change it to a '.'
  newMap = newMap.substr(0, index) + '.' + newMap.substr(index+1);
  // destroy land to the right
  if (newMap[index+1] === '0') {
    newMap = destroyIsland (index+1, xLength, newMap);
  }
  // destroy land below
  if (newMap[index+xLength+1] === '0') {
    newMap = destroyIsland (index+xLength+1, xLength, newMap);
  }
  // destroy land to the left
  if (newMap[index-1] === '0') {
    newMap = destroyIsland (index-1, xLength, newMap);
  }
  // destroy land above
  if (newMap[index-xLength-1] === '0') {
    newMap = destroyIsland (index-xLength-1, xLength, newMap);
  }
  return newMap;
}
```

### Building Stair-Step Strings

Write a function that takes in a string and creates a step with that word. 

E.g `wordStep('SNAKES SHOE EFFORT TRUMP POTATO')` ===

```js
/*
[['S','N','A','K','E','S',' ',' ',' ',' ',' ',' ',' ',' ',' ',' '],
 [' ',' ',' ',' ',' ','H',' ',' ',' ',' ',' ',' ',' ',' ',' ',' '],
 [' ',' ',' ',' ',' ','O',' ',' ',' ',' ',' ',' ',' ',' ',' ',' '],
 [' ',' ',' ',' ',' ','E','F','F','O','R','T',' ',' ',' ',' ',' '],
 [' ',' ',' ',' ',' ',' ',' ',' ',' ',' ','R',' ',' ',' ',' ',' '],
 [' ',' ',' ',' ',' ',' ',' ',' ',' ',' ','U',' ',' ',' ',' ',' '],
 [' ',' ',' ',' ',' ',' ',' ',' ',' ',' ','M',' ',' ',' ',' ',' '],
 [' ',' ',' ',' ',' ',' ',' ',' ',' ',' ','P','O','T','A','T','O']]
*/
```

Every word will end with the character that the next word will start with. You will start top left of the array and end bottom right. All cells that are not occupied by a letter needs to be a space ' '

```js
function wordStep(str) {
  let wordsArr = str.split(' ').map(word => word.slice(1));
  wordsArr[0] = str.charAt(0) + wordsArr[0];
  let cols = 0;
  let rows = 1;
  let passedCols = 0;
  let passedRows = 0;
  let outArr = [];

  // Calc rows and cols number
  wordsArr.forEach((word, index) => {
    if (index % 2) {
      rows += word.length;
    } else {
      cols += word.length;
    }
  });

  // Use calculated data to create array
  for (let i = 0; i < rows; i++) {
    let row = new Array(cols).fill(' ');
    outArr.push(row);
  }

  // Fill table
  wordsArr.forEach((word, index) => {
    if (index % 2) {
      // Fill Y
      word.split('').forEach(char => {
        outArr[passedRows][passedCols] = char;
        passedRows++;
      });

      passedCols++; // Next word should start at next column
      passedRows--; // Keep at same rows with first char
    } else {
      // Fill X
      word.split('').forEach(char => {
        outArr[passedRows][passedCols] = char;
        passedCols++;
      });

      passedRows++; // â†‘ â†‘ â†‘ â†‘
      passedCols--; // Same reason as fill Y
    }
  });

  return outArr;
}
```

```js
describe('wordStep function', function() {
  it('should return a matrix of awesomeness with a few words', function() {
    var longStr = 'SNAKES SHOE EFFORT TRUMP POTATO'
    expect(wordStep(longStr)).to.deep.equal(
      [['S','N','A','K','E','S',' ',' ',' ',' ',' ',' ',' ',' ',' ',' '],
       [' ',' ',' ',' ',' ','H',' ',' ',' ',' ',' ',' ',' ',' ',' ',' '],
       [' ',' ',' ',' ',' ','O',' ',' ',' ',' ',' ',' ',' ',' ',' ',' '],
       [' ',' ',' ',' ',' ','E','F','F','O','R','T',' ',' ',' ',' ',' '],
       [' ',' ',' ',' ',' ',' ',' ',' ',' ',' ','R',' ',' ',' ',' ',' '],
       [' ',' ',' ',' ',' ',' ',' ',' ',' ',' ','U',' ',' ',' ',' ',' '],
       [' ',' ',' ',' ',' ',' ',' ',' ',' ',' ','M',' ',' ',' ',' ',' '],
       [' ',' ',' ',' ',' ',' ',' ',' ',' ',' ','P','O','T','A','T','O']]
      );
     });

  it('should return a matrix of awesomeness with more words', function() {
    var longStr = 'WORDS STILL LINK KINDLY YEAR REGULAR'
    expect(wordStep(longStr)).to.deep.equal(
      [ [ 'W', 'O', 'R', 'D', 'S', ' ', ' ', ' ', ' ', ' ', ' ' ],
        [ ' ', ' ', ' ', ' ', 'T', ' ', ' ', ' ', ' ', ' ', ' ' ],
        [ ' ', ' ', ' ', ' ', 'I', ' ', ' ', ' ', ' ', ' ', ' ' ],
        [ ' ', ' ', ' ', ' ', 'L', ' ', ' ', ' ', ' ', ' ', ' ' ],
        [ ' ', ' ', ' ', ' ', 'L', 'I', 'N', 'K', ' ', ' ', ' ' ],
        [ ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'I', ' ', ' ', ' ' ],
        [ ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'N', ' ', ' ', ' ' ],
        [ ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'D', ' ', ' ', ' ' ],
        [ ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'L', ' ', ' ', ' ' ],
        [ ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'Y', 'E', 'A', 'R' ],
        [ ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'E' ],
        [ ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'G' ],
        [ ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'U' ],
        [ ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'L' ],
        [ ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'A' ],
        [ ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'R' ] ]
      );
  });
});
```

### Accumulate String

Create a function accum that takes a string and outputs a string with the following:

```js
/*
accum("abcd") --> "A-Bb-Ccc-Dddd"
accum("RqaEzty") --> "R-Qq-Aaa-Eeee-Zzzzz-Tttttt-Yyyyyyy"
accum("cwAt") --> "C-Ww-Aaa-Tttt"
*/
```

```js
describe('accum function', function() {
  it('should return a string', function() {
    expect(accum('abcd')).to.be.a('string');
  });
  it('should have an upper case letter followed by incrementing letters separated by dash', function() {
    expect(accum('abcd')).to.be.equal('A-Bb-Ccc-Dddd');
    expect(accum('RqaEzty')).to.be.equal('R-Qq-Aaa-Eeee-Zzzzz-Tttttt-Yyyyyyy');
    expect(accum('cwAt')).to.be.equal('C-Ww-Aaa-Tttt');
    expect(accum('a')).to.be.equal('A');
  });
});
```

```js
function accum(s) {
  var str = '';
  s = s.split('');
  s.forEach(function(el,i) { 
    for(var j = 0; j < i+1; j++) {
      var letter = j > 0 ? s[i].toLowerCase() : s[i].toUpperCase(); 
      str += letter;
    }
    if(i < s.length-1) str += '-';
  });
  return str;
}
```

### Truncation

Truncate a string (first argument) if it is longer than the given maximum string length (second argument). Return the truncated string with a ... ending.  Note that inserting the three dots to the end will add to the string length. However, if the given maximum string length num is less than or equal to 3, then the addition of the three dots does not add to the string length in determining the truncated string.

```js
describe('truncateString function', function() {
  var longStr = "Sriracha gluten-free farm-to-table slow-carb gastropub.";
  it('should return a string', function() {
    expect(truncateString("Hello World",5)).to.be.a('string');
  });

  it('should return a truncated string', function () {
    expect(truncateString('Hello World',5)).to.equal('He...');
    expect(truncateString(longStr,14)).to.be.equal("Sriracha gl...");
  });

  it('should add dots starting at the num if num is 3 or less', function() {
    expect(truncateString('Hello World',2)).to.be.equal('He...');
    expect(truncateString("A-", 1)).to.be.equal('A...');
  });

  it('should return the entire string if num is greater than string length', function() {
    expect(truncateString('Hello World'),20).to.be.equal('Hello World');
    expect(truncateString(longStr,100)).to.be.equal(longStr);
  });
});
```

```js
function truncateString(str, num) {
  // Clear out that junk in your trunk
  if(str.length > num) {
    if(num <= 3) {
      str = str.slice(0,num) + '...';
    } else {
      str = str.slice(0,num-3) + '...';
    }
  }
  return str;
}
```

### String Ending Matching

Check if a string (first argument) ends with the given target string (second argument). Return a Boolean value.

Examples: 

// confirmEnding("Bastian", "n") -> true
// confirmEnding("Connor", "n") -> false
// confirmEnding("He has to give me a new name", "name") -> true

```js
describe('confirmEnding function', function() {
  it('should return a boolean', function() {
    expect(confirmEnding('Bastian','n')).to.be.a('boolean');
  });
  it('should return true when target is at the end of the string', function() {
    expect(confirmEnding('Bastian','n')).to.be.equal(true);
    expect(confirmEnding("He has to give me a new name", "name")).to.be.true;
    expect(confirmEnding("He has to give me a new name", "me")).to.be.true;
  });
  it('should return false when target is not at the end of a string', function() {
    expect(confirmEnding("Connor", "n")).to.be.false;
    expect(confirmEnding("Walking on water and developing software from a specification are easy if both are frozen", "specification")).to.be.false;
    expect(confirmEnding("He has to give me a new name", "na")).to.be.false;
    expect(confirmEnding("If you want to save our world, you must hurry. We dont know how much longer we can withstand the nothing", "mountain")).to.be.false;
  });
});
```

```js
function confirmEnding(str, target) {
  // "Never give up and good luck will find you."
  // -- Falcor
  var lastWord = str.split(' ').pop();
  return lastWord.slice(-target.length) === target;
}
```

### Reverse Vowels

Write a function that takes a string as input and reverse only the vowels of a string.

Example 1:

Given s = "hello", return "holle".

Example 2:

Given s = "wookiE", return "wEikoo".

```js
describe('reverseVowels function', function() {
  it('should return a string of length 1', function() {
    expect(reverseVowels('a')).to.be.equal('a');
  });
  it('should return a string if there is only one vowel', function() {
    expect(reverseVowels('abc')).to.be.equal('abc');
  });
  it('should reverse the vowels of a string', function() {
    expect(reverseVowels('hello')).to.be.equal('holle');
    expect(reverseVowels('hElLo')).to.be.equal('holLE');
    expect(reverseVowels('wookiE')).to.be.equal('wEikoo');
  });
});
```

```js
function reverseVowels (s) {
    var vowels = {'a':1, 'e':1,'i':1,'o':1,'u':1};
        var found = [];
        
        s = s.split('');
        for(var i =0; i < s.length; i++) {
            if(vowels[s[i].toLowerCase()]) {
                found.push(s[i]);
            }
        }
        for(var j =0; j < s.length; j++) {
            if(vowels[s[j].toLowerCase()]) {
                s[j]= found.pop();
            }
        }
        return s.join('');
}
```

### Double Characters

Given a string, you have to return a string in which each character (case-sensitive) is repeated once. If anything but a string is passed to the function, return "Ruh roh! That isn't a string!"

```js
doubleChar("String") ==> "SSttrriinngg"

doubleChar("Hello World") ==> "HHeelllloo  WWoorrlldd"

doubleChar("1234!_ ") ==> "11223344!!__  "
Good Luck!
```

DONE?? Do it with a RegEx! (a 2 line solution is possible)

```js
describe("double char warmup", function() {
  it("should return a string with each character doubled or specific error message", function () {
    expect(doubleChar("Hello World")).to.be.equal("HHeelllloo  WWoorrlldd")
    expect(doubleChar("Tonight we're gonna party like it's 1999")).to.be.equal("TToonniigghhtt  wwee''rree  ggoonnnnaa  ppaarrttyy  lliikkee  iitt''ss  11999999")
    expect(doubleChar(false)).to.be.equal("Ruh roh! That isn't a string!")
    expect(doubleChar(44)).to.be.equal("Ruh roh! That isn't a string!")
    expect(doubleChar(undefined)).to.be.equal("Ruh roh! That isn't a string!")
    expect(doubleChar(NaN)).to.be.equal("Ruh roh! That isn't a string!")

  })
})
```

```js
function doubleChar(str) {
  if (typeof str === "string") return str.replace(/(.)/g, "$1$1")
  return "Ruh roh! That isn't a string!"
}
```

### Remove Vowels

Trolls are attacking your comment section!

A common way to deal with this situation is to remove all of the vowels from the trolls' comments, neutralizing the threat.

Your task is to write a function that takes a string and return a new string with all vowels removed.

For example, the string "This website is for losers LOL!" would become "Ths wbst s fr lsrs LL!".

```js
describe("troll stopper", function() {
  it('when a string is passed in, expect all vowels to be removed', function() {
    expect(antiTroll("aba")).to.be.equal("b")
    expect(antiTroll("fish")).to.be.equal("fsh")
    expect(antiTroll("so long and thanks for all the fish")).to.be.equal("s lng nd thnks fr ll th fsh")
  })
})
```

```js
function antiTroll (string) {
  return string.replace(/[aeiou]/gi, '');
}
```

### Replace With Alphabet Position

Given a string, replace every letter with its position in the alphabet. If anything in the text isn't a letter, ignore it and don't return it. a being 1, b being 2, etc. As an example:

```js
alphabet_position("The sunset sets at twelve o' clock.")

// Should return "20 8 5 19 21 14 19 5 20 19 5 20 19 1 20 20 23 5 12 22 5 15 3 12 15 3 11" (As a string.)
```

```js
describe("alphabet position function", function() {
  it('when a string is passed in, expect each letter to be replaced with its numerical position in the alphabet', function() {
    expect(program("aba")).to.be.equal("1 2 1")
    expect(program("fish")).to.be.equal("6 9 19 8")
    expect(program("The sunset sets at twelve o' clock.")).to.be.equal("20 8 5 19 21 14 19 5 20 19 5 20 19 1 20 20 23 5 12 22 5 15 3 12 15 3 11")
    expect(program("so long and thanks for all the fish")).to.be.equal("19 15 12 15 14 7 1 14 4 20 8 1 14 11 19 6 15 18 1 12 12 20 8 5 6 9 19 8")
  })
})
```

```js
function alphabetPosition(text) {
  var result = "";
  for (var i = 0; i < text.length; i++){
    var code = text.toUpperCase().charCodeAt(i)
    if (code > 64 && code < 91) result += (code - 64) + " ";
  }

  return result.slice(0, result.length-1);
}
```

### String Frequency Count

Write a function charCounts that when given a string, produces a map of character counts. Usage would look like:

```
> console.log(charCounts("This is a string!!!"))
{ T: 1, h: 1, i: 3, s: 3, ' ': 3, a: 1, t: 1, r: 1, n: 1, g: 1, '!': 3 }

> console.log(charCounts("!Data!Is~The*Coolest"))
{ '!': 2,
  D: 1,
  a: 2,
  t: 2,
  I: 1,
  s: 2,
  '~': 1,
  T: 1,
  h: 1,
  e: 2,
  '*': 1,
  C: 1,
  o: 2,
  l: 1 }
```

### Capitalize First Two Words

Write a function that will capitalize not only the first word of the fish in the array, but the second as well.

var fish = [ "rainbow trout", "smallmouth bass", "white bass", "channel catfish" ]

capitalizeFish(fish)
//-> ["Rainbow Trout", "Smallmouth Bass", "White Bass", "Channel Catfish"]

### Find the Path to a String Match in JSON

Write a function which prints the "path" to the string in a given JSON object.

For example, if looking for "full-stack" in the following JSON, our function should return caki -> cyd -> qembsejm -> 1

```
{"dlpgcack": false, "indwqahe": null, "caki": {"vvczskh": null, "tczqyzn":
false, "qymizftua": "jfx", "cyd": {"qembsejm": [null, "full-stack", null],
"qtcgujuki": 79, "ptlwe": "lrvogzcpw", "jivdwnqi": null, "nzjlfax": "xaiuf",
"cqajfbn": true}, "kbttv": "dapsvkdnxm", "gcfv": 43.25503357696589}, "cfqnknrm":
null, "dtqx": "psuyc", "zkhreog": [null, {"txrhgu": false, "qkhe": false,
"oqlzgmtmx": "xndcy", "khuwjmktox": 48, "yoe": true, "xode": "hzxfgvw",
"cgsciipn": 20.075297532268902}, "hducqtvon", false, [null, 76.8463226047357,
"qctvnvo", null], [null, {"nlp": false, "xebvtnvwbb": null, "uhfikxc": null,
"eekejwjbe": false, "jmrkaqky": null, "oeyystp": false}, [null, 10, "nyzfhaps",
71, null], 40, null, 13.737832677566875], [true, 80, 20, {"weynlgnfro":
40.25989193717965, "ggsirrt": 17, "ztvbcpsba": 12, "mljfh": false, "lihndukg":
"bzebyljg", "pllpche": null}, null, [true, false, 52.532666161803895, "mkmqrhg",
 "kgdqstfn", null, "szse"], null, {"qkhfufrgac": "vpmiicarn", "hguztz":
 "ocbmzpzon", "wprnlua": null}], {"drnj": [null, false], "jkjzvjuiw": false,
 "oupsmgjd": false, "kcwjy": null}]}
```

### String Permutations Checker

Given two strings, write a function that decides if one is a permutation of the other.

The function should return a boolean.

### Parse Query Strings

Query strings are often used to pass data from one "page" to another, through the URL. The query string is a list of key-value pairs at the end of a URL. The query string always starts with a ?, and the key-value pairs are separated by &'s. Take a look at the following examples:

http://www.yelp.com/search?find_desc=tacos&find_loc=San+FranciscoCA

http://www.reddit.com/r/aww/search?q=dogs&sort=top&t=week

Write a function called parseQueryString which takes a URL string as an argument and returns a Javascript object containing the key-value pairs from the query string. For example:

```
parseQueryString("http://www.yelp.com/search?find_desc=tacos&find_loc=San+FranciscoCA")

//=> {find_desc: "tacos", find_loc: "San+FranciscoCA"}

parseQueryString("http://www.reddit.com/r/aww/search?q=dogs&sort=top&t=week")

//=> {q: "dogs", sort: "top", t: "week"}
```

### Unique Character Checker

Given a string, determine if all of the characters in the string are unique or not. This function, allCharsUnique should return a Boolean value.

### Vowel Checker

Write a function that takes in 1 input: a letter from the english alphabet.

The function should return a boolean that expresses wether or not the letter is a vowel.

The function should contain NO if statements.

### Parens Checker

Write a function parensChecker which takes a single string arguement consisting of a bunch of parentheses. The function should return true if the string is a valid parentheses expression. For example:

parensChecker("()(((())))")
//=> true

parensChecker("())))(")
//=> false

parensChecker(")(")
//=> false


```
/* 
  This simple testing is part of linting, and part of language design. 
  When you run a JS file, you are notified if you have mis-matching
  parenthesis.

  A common way of solving this problem is to use a data structure called
  a stack. A stack is a "first in last out" container, this is the opposite
  of a queue. Imagine a stack of plates - only the very top plate is
  accessable at any given time, even though we can SEE all the plates.
*/

function parensChecker(input){
	// Opening and closing parens have different behavior
	var types = {
		'(': 'opener',
		'{': 'opener',
		'[': 'opener',
		')': 'closer',
		'}': 'closer',
		']': 'closer'
	};

	// When we encounter an opening brace we have to push it's
	// matching brace to the stack
	var matchingBrace = {
		'(': ')',
		'{': '}',
		'[': ']'
	};

	// We're using a list but only modify it with push and pop
	// which makes it a stack
	var stack = [];	

	for(var i = 0; i < input.length; i++) {
		var currentBrace = input[i];
		
		// You're always allowed to add an opener, so just push
		// the matching closing brace
		if(types[currentBrace] === 'opener') {
			stack.push(matchingBrace[currentBrace]);
		}
		// If we're closing, then the top of our stack must
		// match the current brace, or we have a mis-match
		else if(types[currentBrace] === 'closer') {
			var stackTop = stack[stack.length - 1];
			
			// Any mismatch makes the whole string invalid
			// so quit early.
			if(stackTop !== currentBrace) {
				return false;
			}

			// If we're valid so far, remove this closing brace
			// from the stack.
			stack.pop();
		}
		// If a non brace character is found, return false
		else {
			return false;
		}
	}

	// Lets say all the closing braces matched some opening brace
	// but our stack still has some braces. This means we had input
	// with more openers than closers, such as "(()". 
	if(stack.length !== 0) {
		return false;
	}

	// If we didn't fail, then we must have succeeded.
	return true;
};
```

```js
function test(parensCheckFunction) {
	var testCases = {
		'((': false,
		"()(((())))": true,
		"())))(": false,
		")(": false,
		"([{}])": true,
		"([([[{(){}[()]}]])])": true,
		"}{": false,
		"[][][]{}(){[]}({})": true,
		"[]{}()fail": false,
	};
	var allTestsPass = true;
	for(parenString in testCases) {
		var expected = testCases[parenString];
		var actual = parensChecker(parenString);

		if(expected !== actual) {
			console.log("Failure for " + parenString);
			console.log("  expected: " + expected);
			console.log("  actual:   " + actual);
			allTestsPass = false;
		}
	}

	if(allTestsPass) {
		console.log("all tests pass");
	}
};

test(parensChecker);
```

```js
describe('ParensChecker', function() {
	it('should return true for valid nested parens', function() {
		expect(parensChecker("[]")).to.equal(true);
		expect(parensChecker("()")).to.equal(true);
		expect(parensChecker("{}")).to.equal(true);
		expect(parensChecker("([([[{(){}[()]}]])])")).to.equal(true);
		expect(parensChecker("[][][]{}(){[]}({})")).to.equal(true);
	})

	it('should return false for invalid nested parens', function() {
		expect(parensChecker('][')).to.equal(false);
		expect(parensChecker('((')).to.equal(false);
		expect(parensChecker(')(')).to.equal(false);
		expect(parensChecker('}{')).to.equal(false);
		expect(parensChecker('())))(')).to.equal(false);
		expect(parensChecker('[]{}()fail')).to.equal(false);
	})

	it('should gracefully return false for invalid inputs', function() {
		expect(parensChecker()).to.equal(false);
		expect(parensChecker(false)).to.equal(false);
		expect(parensChecker("foo")).to.equal(false);
		expect(parensChecker(12233)).to.equal(false);
		expect(parensChecker("")).to.equal(false);
		expect(parensChecker(true)).to.equal(false);
		expect(parensChecker(undefined)).to.equal(false);
	})
})


var testCases = {
	'((': false,
	"()(((())))": true,
	"())))(": false,
	")(": false,
	"([{}])": true,
	"([([[{(){}[()]}]])])": true,
	"}{": false,
	"[][][]{}(){[]}({})": true,
	"[]{}()fail": false,
}
```

### Reverse a String Pure

Write a function named reverse that takes a string argument and returns the string reversed. The string provided as the argument should not be modified.

### Reverse a String In Place

Write a function named reverse that takes a string argument and returns the string reversed, but this time the string argument should be modified.

### Enumerate String Reversal Strategies

How many ways can you reverse a string? Come up with at least 3 techniques.

### Strip Whitespace

Write a function called strip which removes all leading and trailing whitespace from a string, but preserves whitespace not found at the beginning or end of the string.

### Double Consonants

Write a function translate that will return a version of the string that has been translated into "rÃ¶varsprÃ¥ket". That is, double every consonant and place an occurrence of "o" in between. For example:

translate("this is fun")
//=> "tothohisos isos fofunon"

### Identify Vowels

Write a function that pulls the vowels out of a string and tells you the number of vowels. The function should return an array with the vowels used and the number of vowels as the last item in the array as â€œn vowels". If a vowel is used more than once in the array it will NOT appear in the array more than once.

```js
var string = â€œI donâ€™t know if this sentence has vowels in it.â€

findVowels(string)
 //-> [ â€œiâ€, â€œoâ€, â€œeâ€, â€œaâ€, "4 vowels" ]
```

### Count Vowels

Write a function that takes a string and returns an object with the vowels in that string as keys and their value is how many times they occurred in the string. The counter function should not care about case. The keys in the object should all be lowercase.

Ex: `countVowels('aAbcdade')` -> `{a:3,e:1}`

```js
describe('countVowels function', function() {
  it('should return an object with the count of the vowels', function() {
    expect(countVowels('aAbcdad')).to.be.eql({a:3});
    expect(countVowels('ddDDddDcD')).to.be.eql({});
    expect(countVowels('zbErtyA')).to.be.eql({a:1,e:1});
    expect(countVowels('aAbcdade')).to.be.eql({a:3,e:1});
  });
});
```

```js
// Iterative
function countVowels(s) {
  var total = {};
  for(var i = 0; i < s.length; i++) {
    var curLetter = s[i].toLowerCase();
    if(total[curLetter]) {
      total[curLetter]++;
    } else {
      total[curLetter] = 1;
    }
  }
  return total;
}
```

```js
// Applicative
function countVowels(s) {
  var vowels = s.match(/[aeiou]/gi) || [];
  var vowelCount = {};
  vowels.forEach(function(el) {
    var curLetter = el.toLowerCase();
    if(vowelCount[curLetter]) {
      vowelCount[curLetter]++;
    } else {
      vowelCount[curLetter] = 1;
    }
  });
  return vowelCount;
}
```

### Remove Duplicate Characters

Write a function named removeDupes which takes a string and removes all duplicate characters in the String. Here are some examples:

```  
  removeDupes('AABB'); // 'AB'
  removeDupes('AaAaBbBb'); // 'AaBb'
  removeDupes('cAtCaT'); // 'cAtCaT'
```

```js
describe('dupeRemover function', function() {
  it('should return a string', function() {
    expect(removeDupes.removeDupes('AABB')).to.be.a('string');
  });
  it('should return a string without duplicates', function() {
    expect(removeDupes.removeDupes('AABB')).to.be.equal('AB');
    expect(removeDupes.removeDupes('AaAaBbBb')).to.be.equal('AaBb');
    expect(removeDupes.removeDupes('cAtCaT')).to.be.equal('cAtCaT');
    // expect(removeDupes.removeDupes("aa".match(/[a-zA-Z]/))).to.equal()
  });
});
```

### Remove Duplicate Characters Case Insensitive

Write a function named insensitiveRemoveDupes which takes a string and removes all duplicate characters regardless of capitalization. Here are some examples:

```
  removeDupes('AABB'); // 'AB'
  removeDupes('AaAaBbBb'); // 'AB'
  removeDupes('cAtCaT'); // 'cAt'
```

```js
describe('dupeRemoverCI function', function() {
  it('should return a string', function() {
    expect(removeDupes.removeDupesCI('AABB')).to.be.a('string');
  });
  it('should return a string with no dupes and is case insensitive', function() {
    expect(removeDupes.removeDupesCI('AABB')).to.be.equal('AB');
    expect(removeDupes.removeDupesCI('AaAaBbBb')).to.be.equal('AB');
    expect(removeDupes.removeDupesCI('cAtCaT')).to.be.equal('cAt');
  });
});
```
### Palindrome Checker

Write a function named isPalindrome that takes a string and determines if it is a palindrome.

## Arrays

### Sorting Callbacks

Present your students with sortingCallbacks.js and ask them to fill in the empty functions. Each function is used as a comparison function for `Aray.prototype.sort` near the bottom. Have your students test their code by uncommenting each `objects.sort` call and examining the results. 

When they're done, present the solution. The solutions provided are fairly explicit and not compact. The numeric sorting should be pretty consistent, but there are many ways to do the letter sorting. Here are some alternatives that students might also benefit from seeing:

```
function sortByLetter(first, second) {
    return first.letter.localeCompare(second.letter);
}

function sortByLetter(first, second) {
    var a = first.letter.toLowerCase();
    var b = second.letter.toLowerCase();
    if (a < b) {
            return -1;
        }
    if (a > b) {
        return 1;
    }
    if (a === b) {
        return 0;
    }
}

function sortByLetterCapsFirst(first, second) {
    return first.letter.charCodeAt(0) - second.letter.charCodeAt(0);
}

function sortByLetterCapsFirst(first, second) {
    var a = first.letter;
    var b = second.letter;
    if (a < b) {
            return -1;
        }
    if (a > b) {
        return 1;
    }
    if (a === b) {
        return 0;
    }
}
```

```js
// This function generates 100 objects with 3 properties each. The properties are all random, two are floating point numbers
and the third is a random letter. (maybe capitalized, maybe not)

function generateRandomObjects() {
	var objects = [];
	var alphaChars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
	// Add 100 random integers between 0-100 to each
	for(var i = 0; i < 100; i++) {
		var obj = {};
		obj.numberOne = Math.floor(Math.random() * 100);
		obj.numberTwo = Math.floor(Math.random() * 100);
		obj.letter = alphaChars[Math.floor(Math.random() * 52)];
		objects.push(obj);
	}
	return objects;
}

// 100 objects.
var objects = generateRandomObjects();

// Your task is to fill out the following functions that can be used as 
// compare functions. Do as many as you can. 
// See these docs for more reference on compare functions:
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort

// The objects should be sorted by numberOne in ascending order (low to high)
function sortByNumberOneAscending(first, second) {
    return first.numberOne - second.numberOne;
}

// The object should be sorted by numberTwo in descending order (high to low)
function sortByNumberTwoDescending(first, second){
	return second.numberTwo - first.numberTwo;
}

// The numbers should be sorted by the sum of numberOne and numberTwo 
// in ascending order
function sortByNumberSum(first, second) {
	var sumOne = 0;
	var sumTwo = 0;
	sumOne += (first.numberTwo + first.numberOne);
	sumTwo += (second.numberOne + second.numberTwo);

	return sumOne - sumTwo;
}

// The objects should be sorted by letter a-z where the case does not affect sort order meaning the order aAaAaaaAAAa is valid and correctly sorted. 
function sortByLetter(first, second) {
	// ?? two lines of code ... 
	var firstUpper = first.letter.toUpperCase();
	var secondUpper = second.letter.toUpperCase();

	if (firstUpper < secondUpper) {
		return -1; 
	}
	else if(firstUpper > secondUpper) {
		return 1;
	}

	return 0
}

// The object should be sorted by letter A-Z then a-z. Meaning, any capital letter should come before every lowercase letter. Meaning AABBCCaabbcc is correctly sorted
function sortByLetterCapsFirst(first, second) {
	'A' > 'B'; 
	
	return first.letter.charCodeAt(0) - second.letter.charCodeAt(0);
}

console.log("Unsorted -----")
console.log(objects);

// Uncomment these lines to see the result of your functions
console.log("\n\nSort by Number One Asc-----")
objects.sort(sortByNumberOneAscending);
console.log(objects);

console.log("\n\nSort by Number Two Desc-----")
objects.sort(sortByNumberTwoDescending);
console.log(objects);

console.log("\n\nSort by Number Sum -----")
objects.sort(sortByNumberSum);
console.log(objects);

console.log("\n\nSort by Letter -----")
objects.sort(sortByLetter);
console.log(objects);

console.log("\n\nSort by Letter Caps First -----")
objects.sort(sortByLetterCapsFirst);
console.log(objects);

```


### Merge and Sort

Write a function that takes two arrays and returns a new array with all items in alphabetical order.

```js
var array1 = [ "cat", "dog", "fish", "zebra" ],
    array2 = [ "lion", "aardvark", "gorilla" ]

alphanimal(array1, array2);
//-> [ "aardvark", "cat", "dog", "fish", "gorilla", "lion", "zebra" ]
```

```js
var array1 = [ "cat", "dog", "fish", "Zebra" ],
    array2 = [ "lion", "aardvark", "gorilla" ]

console.log(alphanimal(array1, array2));

function alphanimal(a1, a2) {
	var flatAr = [];
	var sortedAr = [];
	
	// Flatten the array into a single array
	for(index in a2) {
		flatAr.push(a2[index]);
	}
	for(index in a1) {
		flatAr.push(a1[index]);
	}

	// Once flattened, I'll perform "selection sort" which is not super
	// fast, but it's easy to understand.
	while(sortedAr.length < (a1.length + a2.length)) {
		var best = _pluckHighest(flatAr)
		sortedAr.push(best);
	}

	return sortedAr;
	
	
}

function _pluckHighest(arr) {
		var best = arr[0];
		var bestIndex = 0;
		
		for(index in arr) {
			
			if(arr[index] < best) {
				best = arr[index];
				bestIndex = index;
			}
		}

		return arr.splice(bestIndex, 1)[0];
	}
```

### Map and Reduce

map is a function that allows us to 'map' elements in one array to elements in a new array. It works by creating parallel arrays. Here is the syntax: 

```js
var second = [1,2,3].map(function(item) {
	return item + 1;
}); 

console.log(second) // [2, 3, 4]
```

Use map to take this array of objects and create an array with objects which have had their keys and values swapped

```js
var input = [
	{1: 'a'},
	{2: 'b'},
	{3: 'c'},
	{4: 'd'}
]; 
```

Sample output should be: `[{'a': 1}, {'b': 2}, {'c': 3}, {'d', 4}]`

Take your swapped output once it matches the above comment and map again returning an array where the elements are the concatenation of the keys and values so you should have: `['a1', 'b2', 'c3', d4]`

Once you have the array above, read the 'reduce' fucntion documentation: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce. Feel free to google and find other resources to help you use reduce.

Now, use reduce to return the string 'a1b2c3d4'.

### Sets

As you know by now databases utilize a lot of Set Theory. Lets practice using Sets using a Node library!

Sets are data structures with two important properties. 

1. Sets are not ordered. 
2. Sets can only contain 1 copy of any piece of data. 

Sets also have a rich history in mathematics, and powerful operations that make them very useful. Web developers everywhere are excited about the addition of Sets as a built in data-structure to JavaScript in ES2015, and Node has already built in support for them, HOORAY!

[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set)

To appreciate the value of Sets, lets answer some questions using them. See prompt.js for the specifics of this warmup. In order to access Sets, we have to run Node with a flag that says "we want to use ES2015 features", this is how:

`node --es-staging prompt.js`

Also, do not remove the `'use strict';` from the top of `prompt.js`. 

Tips:

explore the 'spread operator' [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator). Sets are iterable, so you can turn one into an array using code like:

```
var mySet = new Set([1,2,3,4,4]);
var uniqueAsArray = [...mySet] // [1,2,3,4]
``` 

Feel free to Google!

```js
'use strict';
// This should return an array with one copy of each character
// in str, it must however, use a Set to do so. 
function unique(str) {
	var mySet = new Set(str);
	return [...mySet]
}

// This should return a Set with one letter each character that 
// appears in BOTH str1 and str2 (set intersection)
// (hint, use a loop and the .has property of sets
// for (let item of mySet) {//Do stuff}
function intersection(str1, str2) {

}

// This function should return a Set which has all the characters
// that appear in str1 or str2 (set union)
function allLetters(str1, str2) {

}

// This function should return a Set which has 1 copy of each character
// that appears in str1 or in str2 but not in both. 
// hint: (set union - set intersection)
function uniqueLetters(str1, str2) { 

}
```

```js
'use strict';
// This should return an array with one copy of each character
// in str, it must however, use a Set to do so. 
function unique(str) {
	var mySet = new Set(str);
	return [...mySet]
}


// This should return a Set with one letter each character that 
// appears in BOTH str1 and str2 (set intersection)
// (hint, use a loop and the .has property of sets
// for (let item of mySet) {//Do stuff}
function intersection(str1, str2) {
	// First, take the strings and create sets from them
	var setA = new Set(str1);
	var setB = new Set(str2);

	// Now, expand the first set into an array
	var setAsArray = [...setA];

	// Then, using the array built-in filter function
	// add items to intersection, only if they exist in setB
	var intersection = setAsArray.filter(function(item) {
        	return setB.has(item);
        })
	
	// Then, because we said we'd return a set, make a set
	// from intersection, which is an array. 
	return new Set(intersection);
}

// This function should return a Set which has all the characters
// that appear in str1 or str2 (set union)
function allLetters(str1, str2) {
	// Union for sets is easy! 
	// Just concat the strings, then make a set from them. 
	return new Set(str1 + str2); 
}

// This function should return a Set which has 1 copy of each character
// that appears in str1 or in str2 but not in both. 
// hint: (set union - set intersection)
function uniqueLetters(str1, str2) { 
	var intersection = intersection(str1, str2);
	var union = allLetters(str1, str2);

	// This compact version is very much like what we did in 
	// intersection:
	// 1. use the spread operator to get an array
	// 2. use the filter function on arrays
	//    2a. in order to return only items that are NOT in the 
	//        intersection. 
	var difference = new Set(
        [...union].filter(function(item) {
        	return !intersection.has(item);
        }));

	return difference;
}

// Don't forget to test your results!
console.log(intersection('abc', 'cde'));  // c
console.log(allLetters('abc', 'cde'));    // abcde
console.log(uniqueLetters('abc', 'cde')); // abde
```

### Top Three Values

Ask your students to implement a function that takes the top three items from an Array without using Array.prototype.sort. 

Once they've come up with solutions, show them some of the common pitfalls in approaches that we've seen in the past. There are a couple of 'mostly right' solutions in topThreeTopNSolutions.js, as well as code that demonstrates the interesting bugs.

```js
/*
This version of the function will work for many cases. However
if we use 'badly' ordered input arrays this version has a bug. 
Specifically, if the input is already ordered from greatest to
least to some degree.
*/
function topThreeOrderBug(input) {

    // Number.NEGATIVE_INFINITY is a good choice here.
    // This is because we're looking for "max" values
    // and everything is greater than negative infinity. 
    var high = Number.NEGATIVE_INFINITY;
    var mid = Number.NEGATIVE_INFINITY;
    var low = Number.NEGATIVE_INFINITY;
    
    // For every value in the input array
    for (var i = 0; i < input.length; i++ ) {

        // If the current input value is greater than our
        // current max value, we should shift all the values
        // down one.  
        if(input[i] >= high) {
            low = mid;
            mid = high;
            high = input[i];
        }
        // Here is the bug -- what if input[i] is in between low and high,
        // not strictly greater than high?
    }
    
    // Make an array literal with our top values.   
    return [high, mid, low];
};

/*
This version of the function fixes the order bug we saw in the
previous version. Otherwise the code is the same. 
*/
function topThree(input) {
    var high = Number.NEGATIVE_INFINITY;
    var mid  = Number.NEGATIVE_INFINITY;
    var low  = Number.NEGATIVE_INFINITY;

    for(var i = 0; i < input.length; i++){
        var current = input[i];

        if(current > high) {
            low = mid;
            mid = high;
            high = current;
        }
        // Here we added two additional test cases
        // for when the current value is more than mid or low
        // but not more than high.
        else if(current > mid) {
            low = mid;
            mid = current;
        }
        else if(current > low) {
            low = current;
        }
    }

    return [high, mid, low];
}

/*
One of the downfalls of the above approach, is that it's
not clear how I could extend this solution to tackle "max n" 
instead of simply max 3. 

We can't just create an arbitrary number of vars,
since the code needs to be written BEFORE it runs.

In contrast, lets look at another approach to max 3. Here
we will take the input array, find and save the maximum value
from that input array, then remove the max value from the input 
array. 

We'll do that 3 times to get the maximum three.

A downfall of this approach is that input is modified.
Because arrays are reference type the ORIGINAL is CHANGED
when we call input.splice(indexOfMax,1)
*/ 
function topThreeIterative(input){
    var maxArr = [];
    
    // Three times, because we want "max 3"
    for(var j=0; j < 3; j++){
        // Use our helper function to get the highest number
        var topThreeNums = returnMax(input);

        // Put that number in the array to return
        maxArr.push(topThreeNums);

        // Find the index of the max number we just found
        var indexOfMax = input.indexOf(topThreeNums);
        
        // Modify the input array so it no longer contains our max
        input.splice(indexOfMax,1)
    }

    return maxArr;
}

/*
The great thing about this approach, is it's EASY to extend to max n.
I've changed two lines and this code just works. 

First I changed the function header, to accept another parameter 'n'.
*/
function topNIterative(input, n){
    var maxArr = [];
    
    // And this line changed from j < 3 to j < n;
    for(var j=0; j < n; j++){
        
        var topThreeNums = returnMax(input);
        maxArr.push(topThreeNums);

        var indexOfMax = input.indexOf(topThreeNums);
        input.splice(indexOfMax,1)
    }

    return maxArr;

}

// This helper function simply finds and returns the 
// maximum value from an input array.
function returnMax(input){
    var maxNum = input[0];
    for(var i = 1; i < input.length; i++){
        if (input[i] > maxNum){
            maxNum = input[i]
        }
    }
    return maxNum;
}

/*
An alternate approach to top N is to loop through the input
and in a nested loop, go through the 'topN' array. 

Each time we encounter a situation where the current input value
is more than the current 'top' value, we insert that value into 
our top value list. 

This approach does not alter the input array 
*/
function topNAlternate(input, n) {
    
    var topN = [];

    // For each input
    for(var i = 0; i < input.length; i++){
        var current = input[i];

        // For each top value
        for(j = 0; j < n; j++ ){
            var currentTopValue = topN[j];
            
            // If we don't have n elements in our top list yet,
            // or if current > currentTopValue
            if(topN.length < n || current > currentTopValue) {
                // this inserts current into topN at index j.
                // the 0 means "remove 0 elements". 
                topN.splice(j, 0, current);
                break;
            }
        }   
    }
 
    // Because the above code is "add only" topN might actually be
    // longer than n elements, so before we return we slice it. 
    return topN.slice(0, n);
}


/* 
TEST CASES FOR THE DEMONSTRATION 
THE CODE BELOW MAY NOT BE PARTICULARLY INTERESTING OR VALUABLE TO YOU
*/

var rand;
var bigToSmall;
var bigToSmallNegative;
var smallToBig;
var smallToBigNegative;
function resetInputs() {
     rand = {
        test: [1,2,3,4.3,5,-6,7,8,9,-10, 50, 99, Number.POSITIVE_INFINITY, 1, -7],
        expected: [Number.POSITIVE_INFINITY, 99, 50]
    }

    // Ordered content greatest to least
     bigToSmall = {
        test: [10, 9, 8, 7, 6, 5, 4, 3, 2, 1],
        expected: [10, 9, 8]
    }
     bigToSmallNegative = {
        test: [-1, -2, -3, -4, -5 ,-6, -7, -8, -9. -10],
        expected: [-1, -2, -3]  
    } 

    // Ordered content least to greatest
     smallToBig = { 
        test: [0,1,2,3,4,5],
        expected: [5, 4, 3]
    }
    smallToBigNegative = {
        test: [-5, -4, -3, -2, -1, 0, 1, 2],
        expected: [2, 1, 0]
    }  
}

function printResults(testFunc, testObj, n) {
    console.log("Testing " + testFunc.name + " with input " + testObj.test);
    var specialMagic;
    if(n === undefined) {
        console.log("  Expected: " + testObj.expected);
        console.log("  Received: " + testFunc(testObj.test, n));    
    }
    else {
        specialMagic = testFunc(testObj.test, n);
        console.log("  Expected: " + specialMagic);
        console.log("  Received: " + specialMagic);
    }

    console.log();
}

// RUNNING THE DEMONSTRATION CODE
resetInputs();
console.log("============================");
console.log("----------Order Bug---------")
printResults(topThreeOrderBug, rand);
printResults(topThreeOrderBug, bigToSmall);
printResults(topThreeOrderBug, bigToSmallNegative);
printResults(topThreeOrderBug, smallToBig);
printResults(topThreeOrderBug, smallToBigNegative);

console.log("============================");
console.log("------Top Three Fixed-------")
printResults(topThree, rand);
printResults(topThree, bigToSmall);
printResults(topThree, bigToSmallNegative);
printResults(topThree, smallToBig);
printResults(topThree, smallToBigNegative);

console.log("============================");
console.log("----Top Three Iterative-----")
printResults(topThreeIterative, rand);
printResults(topThreeIterative, bigToSmall);
printResults(topThreeIterative, bigToSmallNegative);
printResults(topThreeIterative, smallToBig);
printResults(topThreeIterative, smallToBigNegative);

// Handle that topThree alters the input array
var altRand = rand.test;
var altBS = bigToSmall.test;
var altBSN = bigToSmallNegative.test;
var altSB = smallToBig.test;
var altSBN = smallToBig.test; 
resetInputs();
console.log("BUT LOOK, ALL OF OUR INPUT ARRAYs HAVE CHANGED!!");
console.log(rand.test + " became\n" + altRand + "\n");
console.log(bigToSmall.test+ " became\n" + altBS + "\n");
console.log(bigToSmallNegative.test + " became\n" + altBSN + "\n");
console.log(smallToBig.test + " became\n" + altSB + "\n");
console.log(smallToBigNegative.test + " became\n" + altSBN + "\n");

console.log("============================");
console.log("-------Top N Iterative-----")
printResults(topNIterative, rand, 5);
printResults(topNIterative, bigToSmall, 5);
printResults(topNIterative, bigToSmallNegative, 5);
printResults(topNIterative, smallToBig, 5);
printResults(topNIterative, smallToBigNegative, 5);

resetInputs();
console.log("============================");
console.log("-------Top N Alternate-----")
printResults(topNAlternate, rand, 5);
printResults(topNAlternate, bigToSmall, 5);
printResults(topNAlternate, bigToSmallNegative, 5);
printResults(topNAlternate, smallToBig, 5);
printResults(topNAlternate, smallToBigNegative, 5);
```

### Min Max List Values

Your task is to make two functions, max and min that take a vector of integers list as input and outputs, respectively, the largest and lowest number in that vector.

Examples

```
max([4,6,2,1,9,63,-134,566]) returns 566
min([-52, 56, 30, 29, -54, 0, -110]) returns -110
max([5]) returns 5
min([42, 54, 65, 87, 0]) returns 0
```

Notes: You may consider that there will not be any empty vectors.

```python
class MaxMin(unittest.TestCase):
  def tests_min(self):
    self.assertEqual(prompt.min([-52, 56, 30, 29, -54, 0, -110]), -110)
    self.assertEqual(prompt.min([42, 54, 65, 87, 0]), 0)
    self.assertEqual(prompt.min([1, 2, 3, 4, 5, 10]), 1)
    self.assertEqual(prompt.min([-1, -2, -3, -4, -5, -10]), -10)
    self.assertEqual(prompt.min([9]), 9)

  def tests_max(self):
    self.assertEqual(prompt.max([-52, 56, 30, 29, -54, 0, -110]), 56)
    self.assertEqual(prompt.max([4,6,2,1,9,63,-134,566]), 566)
    self.assertEqual(prompt.max([5]), 5)
    self.assertEqual(prompt.max([534,43,2,1,3,4,5,5,443,443,555,555]), 555)
    self.assertEqual(prompt.max([9]), 9)
```

```python
def min(arr):
    low = arr[0]
    for i in arr[1:]:
        if i < low:
            low = i
    return low

def max(arr):
    high = arr[0]
    for i in arr[1:]:
        if i > high:
            high = i
    return high
```

### Checkerboard

You are trying to make a checkerboard made up of X's and O's. You've implemented the function before in a different language but it just won't work in Python. The function `make_checkered_board(n)` creates an N by N board of X's and O's.

For example

```python
make_checkered_board(4)==
[['X', 'O', 'X', 'O'],
 ['O', 'X', 'O', 'X'],
 ['X', 'O', 'X', 'O'],
 ['O', 'X', 'O', 'X']]
```

```python
class Checkerboard(unittest.TestCase):

  def tests_basic(self):
    self.assertEqual(prompt.make_checkered_board(5),[['X', 'O', 'X', 'O', 'X'],
                                                ['O', 'X', 'O', 'X', 'O'],
                                                ['X', 'O', 'X', 'O', 'X'],
                                                ['O', 'X', 'O', 'X', 'O'],
                                                ['X', 'O', 'X', 'O', 'X']])
```

```python
def make_checkered_board(n):
    line=['X' for x in range(n)]
    board = [line for y in range(n)]
    for row in range(0,n):
        for col in range(0,n):
            if (row+col)%2:
                board[row][col]="0"
    for line in board:
        print(line)
    return board
```

## Memory Game

TDD development by writing your own tests!

In a simple memory game (http://en.wikipedia.org/wiki/Concentration_(game)) we need an array containing tiles represented by integers in pairs.

Memory games basics

In the memory game, numbers are randomly placed face-down in a grid. Each turn, the player chooses a number to peek at, and then replace, face down. If they choose two of the same number in a row, those numbers are removed from the grid. The aim is to clear the board!

Your job is to produce an array of pairs of numbers, placed in a random spot in the array.

The array (and result) could look somthing like:

```
[3,1,2,1,3,2,4,4]
```

for an 8 tile memory game. (4 pairs). createTiles(8)

Your task is to implement the function createTiles(n) where n is the number of tiles. The function should return an array with the length n containing randomized, paired, integers starting with 1. Duplicate pairs are not allowed.

Special cases:

if n is odd or zero, an empty array should be returned

```js
Array.prototype.remove = function(from, to) {
  var rest = this.slice((to || from) + 1 || this.length);
  this.length = from < 0 ? this.length + from : from;
  return this.push.apply(this, rest);
};

function createTiles(n){
  var numbers = [];
  var array = [];
  
  if(n === 0 || n % 2 != 0) {
    return array;
  }
  
  for(var i = 1; i <= n / 2; i++) {
    numbers.push(i);
    numbers.push(i);
  }
  
  do {
    var num = Math.floor(Math.random() * numbers.length);
    array.push(numbers[num]);
    numbers.remove(num);
  } while(numbers.length > 0);
  
  console.log(array);
  return array;
}
```

## Find The Nth Longest Word

Implement the function longest(array,n) where you will be given an array of strings and then return the nth longest string in that array. e.g.

```
arr = ['Hello','World','Flapjack','Quick']
n = 3; 
```

should return 'World' because 'Flapjack' length = 8 , 'Hello' length = 5, so that is the 2nd longest word and then 'World' (although also word length of 5, 'World' is after 'Hello' in the array). 

When words have the same lengths, treat them in the order in which they exist in the array. Array will never be empty and n > 0 always.

```js
describe('nth longest work', function() {
  it('should return the correct word', function() {
    assert.equal(longest(['Hello','World','Codewars','Katas'],3),'World');
    assert.equal(longest(['Hello','World','Codewars','Katas'],4),'Katas');
    assert.equal(longest(['aa', 'bb', 'cc', 'dd', 'eee', 'b', 'f', 'ff', 'hhh', 'gggg'],4),'aa');
    assert.equal(longest(['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'k'],1),'a');
    assert.equal(longest(['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'k','l'],1),'a');
  });
});
```

```js
function longest(arr, n) {
  var longestWord = 0;
  var array = [];
  
  for(var i = 0; i < arr.length; i++) {
    if(arr[i].length > longestWord) {
      longestWord = arr[i].length;
    }
  }
  
  do {
    for(var j = 0; j < arr.length; j++) {
      if(arr[j].length === longestWord) {
        array.push(arr[j]);
      }
    }
    longestWord -= 1;
  } while(longestWord > 0);
  
  return array[n-1];
  
}
```

### Two Dimensional Array Sorting Don't Drink The Water

Given a two-dimensional array representation of a glass of mixed liquids, sort the array such that the liquids appear in the glass based on their density. (Lower density floats to the top) The width of the glass will not change from top to bottom.

```
======================
|   Density Chart    |
======================
| Honey   | H | 1.36 |
| Water   | W | 1.00 |
| Alcohol | A | 0.87 |
| Oil     | O | 0.80 |
----------------------
```

```
[                            [
 ['H', 'H', 'W', 'O'],        ['O','O','O','O']
 ['W', 'W', 'O', 'W'],  =>    ['W','W','W','W']
 ['H', 'H', 'O', 'O']         ['H','H','H','H']
 ]                           ]
```

The glass representation may be larger or smaller. If a liquid doesn't fill a row, it floats to the top and to the left.

```js
describe('Sorting array by liquid density', function() {
  it('Should be able to sort 3 liquids', function() {
    expect(separateLiquids([['H', 'H', 'W', 'O'],['W','W','O','W'],['H','H','O','O']])).to.deep.equal([['O', 'O', 'O', 'O'],['W','W','W','W'],['H','H','H','H']]);
  });

  it('Should be able to handle 4 liquids', function() {
    expect(separateLiquids([['A','A','O','H'],['A', 'H', 'W', 'O'],['W','W','A','W'],['H','H','O','O']])).to.deep.equal(
      [['O','O','O','O'],['A', 'A', 'A', 'A'],['W','W','W','W'],['H','H','H','H']]
      );
  });

  it('Should be able to handle one row', function() {
    expect(separateLiquids([['A','H','W','O']])).to.deep.equal([['O','A','W','H']]);
  });

  it('Should be able to handle one column', function() {
    expect(separateLiquids([['A'],['H'],['W'],['O']])).to.deep.equal([['O'],['A'],['W'],['H']]);
  });

  it('Should be able to handle empty array', function() {
    expect(separateLiquids([])).to.deep.equal([]);
  });

});
```

```js
function separateLiquids(glass) {
  if (glass.length === 0) {return glass}
   
  var temp
  var flatArr = []
  var masterArr = [];
  var glassWidth = glass[0].length;


  for (arr in glass) {
    for (item in glass[arr]) {
      if (glass[arr][item] === "O" ) {
        temp = glass[arr][item]
        flatArr.push({1:"O"});
      } else if (glass[arr][item] === "A" ) {
        temp = glass[arr][item]
        flatArr.push({2:"A"});
      } else if (glass[arr][item] === "W" ) {
        temp = glass[arr][item]
        flatArr.push({3:"W"});
      } else if (glass[arr][item] === "H" ) {
        temp = glass[arr][item]
        flatArr.push({4:"H"});
      } // END IF
    } // END FOR LOOP
  } // END FOR LOOP

  flatObj = flatArr.sort(function(a,b){
    return Object.getOwnPropertyNames(a) - Object.getOwnPropertyNames(b)
  });

  flatArr = [];
  for (x in flatObj) {
    var key = Object.keys(flatObj[x]).toString()
    flatArr.push(flatObj[x][key]);
  }

  var subArr = [];
  for (var i = 0 ; i <= flatArr.length ; i++) {
      if (subArr.length === glassWidth) {
        masterArr.push(subArr)
        subArr = [];
        subArr.push(flatArr[i])
      } else if (subArr.length < glassWidth) {
        subArr.push(flatArr[i]);
      } // END IF
  } // END FOR LOOP

  return masterArr;
}
```

### Compound Array

You have to create a method "compoundArray" which should take as input two int arrays of different length and return one int array with numbers of both arrays shuffled one by one. 

Example: 

```js
/*
compoundArray([1,2,3,4,5,6],[9,8,7,6]) => [1,9,2,8,3,7,4,6,5,6];
*/
```

```js
describe('compoundArray function', function() {
  it('should return an array', function() {
    expect(compoundArray([1,2,3],[4,5,6])).to.be.an('array');
  });
  it('should return a compounded array', function() {
    expect(compoundArray([1,2,3],[4,5,6])).to.be.eql([1,4,2,5,3,6]);
    expect(compoundArray([1,2,3],[4,5,6,7,8,9])).to.be.eql([1,4,2,5,3,6,7,8,9]);
    expect(compoundArray([4,5,6,7,8,9],[1,2,3])).to.be.eql([4,1,5,2,6,3,7,8,9]);
    expect(compoundArray([],[])).to.be.eql([]);
    expect(compoundArray([],[1,2,3])).to.be.eql([1,2,3]);
  });
});
```

```js
function compoundArray(a, b) {
  var result = [];
  for(var i=0;i<Math.max(a.length, b.length); i++) {
    if(!isNaN(a[i])) result.push(a[i]);
    if(!isNaN(b[i])) result.push(b[i]);
  }
  return result;
}
```

### Check Ascending

A function receives an array of positive integers as input. The function should determine whether the numbers are in ascending order. Assume all inputs are valid.

```js
/*
Ex: 
inAscOrder([1,2,3,34]) -> returns true;
inAscOrder([1,2,34,3]) -> returns false;
*/
```

```js
describe('inAscOrder function', function() {
  it('should return a boolean', function() {
    expect(inAscOrder([4,3,2,1])).to.be.a('boolean');
  });
  it('should return true if array is in ascending order', function() {
    expect(inAscOrder([1,2,3,4])).to.be.true;
    expect(inAscOrder([5,6,90])).to.be.true;
    expect(inAscOrder([1,10,100,1000,1001])).to.be.true;
  });
  it('should return false if not ascending order', function() {
    expect(inAscOrder([4,3,2,1])).to.be.false;
    expect(inAscOrder([1,2,4,3])).to.be.false;
    expect(inAscOrder([10,1,100])).to.be.false;
  });
  it('should return true if array has length of 1 or 0', function() {
    expect(inAscOrder([1])).to.be.true;
    expect(inAscOrder([])).to.be.true;
  });
  it('should return false if input is not an array of numbers', function() {
    expect(inAscOrder('foo')).to.be.equal(false);
    expect(inAscOrder(true)).to.be.equal(false);
    expect(inAscOrder(['r',2,true])).to.be.equal(false);
  });

  it('should throw error if input is invalid', function() {
     var fnCall = inAscOrder.bind(null);
     expect(fnCall).to.throw(ReferenceError);
     expect(inAscOrder.bind(null, [])).to.throw(ReferenceError);
   });
});
```

```js
// Solution 1
function inAscOrder(arr) {
  for (var i=1; i<arr.length; ++i) {
    if (arr[i] < arr[i-1]) return false;
  }
  
  return true;
}
```

```js
// Solution 2
function inAscOrder(arr) {
  var copy = arr.slice();
  var sorted = copy.sort(function(a,b){
    return a - b;
  });
  return arr.toString() === sorted.toString();
  
}
```

### Find Similar Items

Given two arrays, find the similar values between both and return those similar values in an array. Do not have duplicate values in the return array.

```js
/*
Ex: findSimilar([1,2,false,[2,3],{foo:'bar'},[5,6],'hi'],[0,2,[5,6],true,'hi',2,1,{foo:'bar'},{bar:'foo'}])
-> [1,2,{foo:'bar'},[5,6],'hi']
*/
```

```js
describe('findSimilar function', function() {
  it('should return an array', function(){
    expect(findSimilar([1,2,false,[2,3],{foo:'bar'},[5,6],'hi'],[0,2,[5,6],true,'hi',2,1,{foo:'bar'},{bar:'foo'}])).to.be.an('array');
  });
  it('should return an empty array if no similarities', function() {
    expect(findSimilar([1,2,3,true],[4,5,6,false])).to.be.empty;
  });
  it('should return an array of similarites', function() {
    var answer = findSimilar([1,2,false,[2,3],{foo:'bar'},[5,6],'hi'],[0,2,[5,6],true,'hi',2,1,{foo:'bar'},{bar:'foo'}]);
    expect(answer).to.include.members([1,2,'hi']);
    expect(answer).to.deep.include.members([{foo:'bar'},[5,6]]);
  });
});
```

```js
function findSimilar(arr1,arr2) {
  // Your solution here
  var hash = {};
  var similarities = [];
  arr1.forEach(function(el) {
    if(typeof el === 'object' && !Array.isArray(el)) {
      var key = JSON.stringify(el);
      if(!hash[key]) {
        hash[key] = 1;
      }
    } else {
      if(!hash[el]) {
        hash[el] = 1;
      }
    }
  });

  arr2.forEach(function(el) {
    if(typeof el === 'object' && !Array.isArray(el)) {
      var key = JSON.stringify(el);
      if(hash[key]) {
        similarities.push(el);
        delete hash[key];
      }
    } else {
      if(hash[el]) {
        similarities.push(el);
        delete hash[el];
      }
    }
  });

  return similarities;
}
```

### Rotate Arrays

Rotate an array arr in place arr to the right by k steps.

For example, with n = [1,2,3,4,5,6,7] and k = 3, the array is rotated to [5,6,7,1,2,3,4]. Make sure not to return a copy of the array.

```js
describe('rotate function', function() {
  it('should return an array', function() {
    var arr = [1,2,3,4,5,6];
    expect(rotate(arr,1)).to.be.an('array');
  });
  it('should return the same array that was input', function() {
    var arr = [1,2,3,4,5,6];
    expect(rotate(arr,1)).to.be.equal(arr);
  });
  it('should return rotated array', function() {
    expect(rotate([1,2,3,4,5,6,7],2)).to.be.eql([6,7,1,2,3,4,5]);
    expect(rotate([1,2,3,4,5,6,7],0)).to.be.eql([1,2,3,4,5,6,7]);
    expect(rotate([1,2,3,4,5,6,7],7)).to.be.eql([1,2,3,4,5,6,7]);
    expect(rotate([1,2,3,4,5,6,7],4)).to.be.eql([4,5,6,7,1,2,3,]);
  });
});
```

```js
function rotate(arr,k) {
  if(k > arr.length) {
          var temp = Math.floor(k/arr.length);
          k = k - temp*arr.length;
      }
      
      for(var j = 0; j < k; j++) {
          var x = arr.pop();
          arr.unshift(x);
      }
  return arr;
}
```

### Flatten Array

Write a function that flattens an Array of Array objects into a flat Array. Your function must only do one level of flattening.

Some examples:

```js
flatten([]) // should return []
flatten([1, 2, 3]) //should return [1,2,3]
flatten([[1, 2, 3], ["a", "b", "c"], [1, 2, 3]]) //should return [1, 2, 3, "a", "b", "c", 1, 2, 3]
flatten([[3, 4, 5], [[9, 9, 9]], ["a,b,c"]]) //should return [3, 4, 5, [9, 9, 9], "a,b,c"]
```

```js
describe('flatten function', function() {
  it('should return an array', function() {
    expect(answer.flatten([])).to.be.an('array');
  });
  it('should return a duplicate array if no nested arrays', function() {
    expect(answer.flatten([])).to.eql([]);
    expect(answer.flatten([1,2,3])).to.eql([1,2,3]);
  });
  it('should return an array with one level of flattening', function() {
    expect(answer.flatten([[1, 2, 3], ["a", "b", "c"], [1, 2, 3]])).to.eql([1, 2, 3, "a", "b", "c", 1, 2, 3]);
    expect(answer.flatten([[3, 4, 5], [[9, 9, 9]], ["a,b,c"]])).to.eql([3, 4, 5, [9, 9, 9], "a,b,c"]);
    expect(answer.flatten([[[3], [4], [5]], [9], [9], [8], [[1, 2, 3]]])).to.eql([[3], [4], [5], 9, 9, 8, [1, 2, 3]]);
  });
});
```

### Implement Every

Write a function named `every` that takes two arguments.
   `arr` (array)
   `predicate` (function)

Return `true` if the `predicate` function returns *truthy* for all elements of `arr`, otherwise return `false`. The `predicate` function is invoked with one argument.

  `element` (anything)

For example:

```
var result = every([1, 2, 3], function(element) {
  return element % 2 === 0;
});


console.log(result); // false

result = every([2, 4, 6], function(element) {
  return element % 2 === 0;
});

console.log(result); // true
```

### Implement .all

This function returns true only if the predicate supplied returns true for all the items in the array

```
[1, 2, 3].all(isGreaterThanZero) => true
[-1, 0, 2].all(isGreaterThanZero) => false
```

```js
describe('array prototype', function() {
  var newArr = new arrayObj(1,2,3);
  var newArr2 = new arrayObj(-1,0,3);
  var newArr3 = new arrayObj(-1,-2,-3);
  it('should work with any method', function() {
    expect(newArr.all).to.be.ok;
    expect(arrayObj.prototype.all).to.be.ok;
  });
  it('all should return true if all pass',function () {
    expect(newArr.all(cb)).to.be.true;
  });
  it('all should return false if not all pass', function() {
    expect(newArr2.all(cb)).to.be.false;
  });
});
```

```js
Array.prototype.all = function (p) {
  for (var i = 0 ; i < this.length ; i++) {
    currentIndex = this[i]
    if (p(currentIndex) === false) {
      return false
    };
  }
  return true
};

// OR

Array.prototype.all = function (p) {
  return this.filter(p).length == this.length;
};
```

### Implement .none

This function returns true only if the predicate supplied returns false for all the items in the array

```js
[-1, 2, 3].none(isLessThanZero) => false
[-1, -2, -3].none(isGreaterThanZero) => true
```

```js
describe('array prototype', function() {
  var newArr = new arrayObj(1,2,3);
  var newArr2 = new arrayObj(-1,0,3);
  var newArr3 = new arrayObj(-1,-2,-3);
  it('should work with any method', function() {
    expect(newArr.none).to.be.ok;
  });
  it('none should return true if none pass', function() {
    expect(newArr3.none(cb)).to.be.true;
  });
  it('none should false if some pass', function() {
    expect(newArr2.none(cb)).to.be.false;
  })
});
```

```js
// [-1, 2, 3].none(isLessThanZero) => false
// [-1, -2, -3].none(isGreaterThanZero) => true
Array.prototype.none = function (p) {
  var count = 0
  for (var i = 0 ; i < this.length ; i++) {
    currentIndex = this[i]
    if (p(currentIndex) !== true) {
      count +=1 
    };
  }
  if (count !== this.length) {
    return false
  }
  return true
};

// OR

Array.prototype.none = function (p) {
  return this.filter(p).length == 0;
};
```

### Implement .any

This function returns true if at least one of the items in the array returns true for the predicate supplied

```js
[-1, 2, 3].any(isGreaterThanZero) => true
[-1, -2, -3].any(isGreaterThanZero) => false
```

```js
describe('array prototype', function() {
  var newArr = new arrayObj(1,2,3);
  var newArr2 = new arrayObj(-1,0,3);
  var newArr3 = new arrayObj(-1,-2,-3);
  it('should work with any method', function() {
    expect(newArr.any).to.be.ok;
    expect(arrayObj.prototype.any).to.be.ok;
  });
  it('any should return true if any pass', function() {
    expect(newArr.any(cb)).to.be.true;
  });
  it('any should return false if none pass', function() {
    expect(newArr3.any(cb)).to.be.false;
});
```

```js
Array.prototype.any = function (p) {
    var count = 0
    for (var i = 0 ; i < this.length ; i++) {
      currentIndex = this[i]
      if (p(currentIndex) === true) {
        console.log(p(currentIndex),"true is true")
        count +=1 
      };
    }
    if (count > 0) {
      return true
    }
    return false
};

// OR

Array.prototype.any = function (p) {
  return this.filter(p).length > 0;
};
```

### Implement Filter

Write a function named `filter` that takes two arguments.
   `arr` (array)
   `predicate` (function)

Iterate over the elements of `arr` and return a _new_ array of all elements the `predicate` function returns truthy for. The `predicate` function is invoked with one argument.

  `element` (anything)

For example:

```
var users = [
  { name: 'Katie', points: 240 },
  { name: 'Ralph', points: 130 }
];

var winners = filter(users, function(element) {
  return element.points >= 200;
});

console.log(winners); // [{ name: 'Katie', points: 240 }]
```

### Implement Intersect

Given two arrays of Numbers, return an array containing elements common to both arrays, for example:

```
  var test1 = [1,2,3,4,5];
  var test2 = [3,4,7,8,9];

  console.log(intersection(test1, test2)); // [3,4]

  var test3 = [];
  console.log(intersection(test1, test3)); // []
  console.log(intersection(test2, test3)); // []
```

### Implement Map

Write a function named `map` that takes two arguments.
   `arr` (array)
   `callback` (function)

Return a _new_ array where each element of `arr` is transformed by the `callback` function and the result is pushed into the new array.

For example:

```
var rounded = map([0.01, 2, 9.89, Math.PI], function(num) {
  return Math.round(num);
});

console.log(rounded); // [0, 2, 10, 3]
```

### Implement Reduce

Write a function named `reduce` that takes three arguments.
   `arr` (array)
   `callback` (function)
   `accum` (initial accumulation value)

Reduce `arr` to a single value by invoking the `callback` function with the `accum` value and each element in `arr`. The return value of each invocation of the `callback` will become the new `accum` value. The `callback` function is invoked with two arguments.

  `accum` (anything)
  `element` (anything)

For example:

```
var result = reduce([1, 2, 3], function(accum, element) {
  return accum + element;
}, 0);

console.log(result); // 6
```

### Average with forEach

Create a function that uses `Array.forEach()` to calculate and return the average of an array's values.

Example:

```
getAverage([1,2,3]);
// => 2
```

### Find All Greater Integers

Implement a function that takes two arguments. The first argument is an array of numbers. The second argument is a number two compare with each item in the array. Your function should return an array of numbers that are greater than the second argument.

Example:

```
findGreater([1,2,3,4,5,6,7,8], 5);
// => [6,7,8]
```

### Element Match Checker

Implement a function which determines whether or not something is in an array. The function should be defined with two parameters, one of which is an array, the other which is either a string or integer. ie: Arguments [1,2,3], and 3, would return true. Arguments [1,2,3], 4, would return false.

### Join and Sort Array

Write a function that takes two arrays and returns a new array with all items in alphabetical order.

```
var array1 = [ "cat", "dog", "fish", "zebra" ],
    array2 = [ "lion", "aardvark", "gorilla" ]

alphanimal(array1, array2);
//-> [ "aardvark", "cat", "dog", "fish", "gorilla", "lion", "zebra" ]
```

### While Loop Number Manipulation

With an array [1,2,3,4,5]. Write a while loop that adds 2 to odd numbers and squares even numbers.
returns:

    3
    4
    5
    16
    7

### Missing Integer Checker

You are given an array with integers between 1 and 100,000, but one integer is missing. Write a function that determines the missing value.

Here is a helper function, written in javascript, to generate an array with one integer removed from it:

```
function arrayBuilder(length) {
  length = length || 100000;
  var removedNumber = Math.floor(Math.random() * length);
  var array = Array.apply(null, Array(length)).map(function (_, i) {return i + 1;});
  array.splice(removedNumber, 1);
  return array;
}
```

### Only Once Checker

Find the only element in an array that only occurs once. For example in [1,2,2,3,3,5,5,1,6], 6 is the only element that occurs precisely one time.

### Grade Deltas

You are given an array of grades.  You need to process this array, and return an array that describes whether each grade
was higher, lower or even to the previous grade.

So given the following array:

```javascript
[6,3,5,4,3,4,4,5]
```

Your code would produce:

```javascript
["down","up","down","down","up","even","up"]
```

When given an empty array, it returns an empty array.

NOTE: your array tracks the differences between grades, so it will be one item _shorter_ than the given array.

### More Than Once Checker

Implement a function which determines if an element appears more than once in an array.

### Implement `indexOf`

Define a function called indexOf that takes in two arguments: an array, and an item that might be in the array. Your function should return the index of the item if it is found within the array; otherwise, it should return -1.

Example:

```
indexOf(['a', 'b', 'c'], 'a');
// => 0

indexOf(['a', 'b', 'c'], 'd');
// => -1
```

### Twice Checker

You are given an array with integers between 1 and 1,000,000. One integer is in the array twice. How can you determine which one?

### Find the Longest String

Write a function that returns the longest string in the array and it's length as an object.

```
arr = ["truck", "sidewalk", "book"]

longString(arr)
//-> longString = { sidewalk: 8 }
```

### `for` and `while` Loop Practice

Write a for loop AND a while that returns the following outputs:

1(odd)
2(even)
3(odd)
4(even)
5(odd)
6(even)
7(odd)
8(even)
9(odd)
10(even)
Conference 1:
Team 1
Team 2
Team 3
Team 4
Conference 2:
Team 1
Team 2
Team 3
Team 4
Conference 3:
Team 1
Team 2
Team 3
Team 4
Conference 4:
Team 1
Team 2
Team 3
Team 4
11 times 1 equals 11
11 times 2 equals 22
11 times 3 equals 33
11 times 4 equals 44
11 times 5 equals 55

### Implementing Max

Given an array of integers, find the maximum value in the array.

### Scores to Letter Grades

given an array of test scores [ 68, 74, 99, 45, 83, 95 ] and the scale: F is less than 60, D is 60 to 69, C is 70 to 79, B is 80 to 89, A is 90 to 100.

Write a function that returns an array:

```
convertToGrade(arr); // => [ D, C, A, F, B, A ]
```

### Zip Arrays

Implement a function which takes two parameters, both of which are arrays, and zips them together. ie: The arguments are [1,2,3], and [4,5,6], and after zipping the two arrays, you return [1,4,2,5,3,6].

### Rotate Even Indexes of a String

Write a function named rotateEvenIndices that take a String argument, here are sample tests to illustrate the behavior:

```
var string = 'foobar';
var rotatedOnce = rotateEvenIndices(string);
console.log(rotatedOnce);

var rotatedTwice = rotateEvenIndices(rotatedOnce);
console.log(rotatedTwice);

var backToOriginal = rotateEvenIndices(rotatedTwice);
console.log(string === backToOriginal); // true
```

### Count Present Sheep

Consider an array of sheep where some sheep may be missing from their place. Write a function that counts the number of sheep present in the array (true means present).

For example,

```
var sheep = [true,  true,  true,  false,
  true,  true,  true,  true ,
  true,  false, true,  false,
  true,  false, false, true ,
  true,  true,  true,  true ,
  false, false, true,  true];

countSheep(sheep);
// => 17
```
The countSheep function, if defined properly, should return 17 in this case.

### Comparing Two Arrays: Conference City Picker

Lucy loves to travel. Luckily she is a renowned computer scientist and gets to travel to international conferences using her department's budget.

Each year, Society for Exciting Computer Science Research (SECSR) organizes several conferences around the world. Lucy always picks one conference from that list that is hosted in a city she hasn't been to before, and if that leaves her with more than one option, she picks the conference that she thinks would be most relevant for her field of research.

Write a function conferencePicker that takes in two arguments:

* `citiesVisited`, a list of cities that Lucy has visited before, given as an array of strings.
* `citiesOffered`, a list of cities that will host SECSR conferences this year, given as an array of strings. `citiesOffered` will already be ordered in terms of the relevance of the conferences for Lucy's research (from the most to the least relevant). The function should return the city that Lucy should visit, as a string.

Also note:

* You should allow for the possibility that Lucy hasn't visited any city before.
* SECSR organizes at least two conferences each year.
* If all of the offered conferences are hosted in cities that Lucy has visited before, the function should return 'No worthwhile conferences this year!' (Nothing in Haskell)

Example:

```js
citiesVisited = ['Mexico City','Johannesburg','Stockholm','Osaka','Saint Petersburg','London'];
citiesOffered = ['Stockholm','Paris','Melbourne'];

// conferencePicker (citiesVisited, citiesOffered);
// // ---> 'Paris'
```

```js
describe("traveler warmup", function() {
  it("should return an offered city that has not been visited", function () {
    citiesVisited = ['Mexico City','Johannesburg','Stockholm','Osaka','Saint Petersburg','London'];
    citiesOffered = ['Stockholm','Paris','Melbourne'];
    expect(program(citiesVisited,citiesOffered)).to.be.equal("Paris")

    citiesVisited = ['Bigfork', 'North Scituate', 'Lake Success', 'Willsboro', 'McConnellsburg'];
    citiesOffered = ['Bigfork', 'North Scituate', 'Lake Success', 'Willsboro', 'McConnellsburg', 'Happytown'];
    expect(program(citiesVisited,citiesOffered)).to.be.equal("Happytown")

  })
  it("should return no city if all are visited", function () {
    citiesVisited = ["Grazierville", "Covelo", "Ridge Wood Heights", "Onancock", "Winthrop Town"];
    citiesOffered = ["Grazierville", "Covelo", "Ridge Wood Heights", "Onancock", "Winthrop Town"];
    expect(program(citiesVisited,citiesOffered)).to.be.equal("No worthwhile conferences this year!")
  })
})
```

```js
function conferencePicker (citiesVisited, citiesOffered) {
  for (x in citiesOffered) {
    var currentCity = citiesOffered[x]
    if (citiesVisited.indexOf(currentCity) === -1){
      return currentCity
    }
  } 
  return 'No worthwhile conferences this year!'
} // END FUNCTION
```
